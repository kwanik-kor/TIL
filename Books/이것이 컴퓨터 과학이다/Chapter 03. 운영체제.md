# 1. 운영체제의 큰 그림
> 다양한 종류의 OS가 존재하지만 종류에 관계 없이 운영체제가 제공하는 핵심적인 기능은 유사함

**커널(kernel)**
- 운영체제의 핵심 기능을 담당하는 부분

**운영체제의 핵심 기능**
- 자원 할당 및 관리
	- **자원(resource)** / 시스템 자원
		- 프로그램 실행에 마땅히 필요한 요소
		- 실행에 필요한 데이터(S/W)
		- 실행에 필요한 부품(H/W)
	- 사용자가 실행하는 응용 프로그램을 대신하여 CPU, 메모리, 보조기억장치 등 컴퓨터 부품에 접근하고, 각 부품들이 효율적으로 사용되도록 관리
- 프로세스 및 스레드 관리

## 1.1 운영체제의 역할

### 1.1.1 CPU 관리: CPU 스케줄링
> 메모리에 실행 중인 프로그램이 다수 적재될 수 있으나, CPU가 이 모두를 동시에 실행할 수는 없음

운영체제는 실행 중인 모든 프로그램들이 공정하고 합리적으로 CPU를 할당받도록 CPU 할당 순서와 사용 시간을 결정해야 함

### 1.1.2 메모리 관리: 가상 메모리

운영체제는 새롭게 실행하는 프로그램을 메모리에 적재하고, 종료된 프로그램을 메모리에서 삭제함. 
동시에 낭비되는 메모리 용량이 없도록 효율적으로 관리해야 함
- 가상 메모리 기술 활용

### 1.1.3 파일/디렉터리 관리: 파일 시스템

메모리보다 더 큰 용량을 갖고 있는 보조기억장치는 더욱 일목요연하게 관리해야 함
보조기억장치를 효율적으로 관리하기 위해 파일 시스템을 활용함

### 1.1.4 프로세스 및 스레드 관리

**프로세스(process)**: 실행중인 프로그램
**스레드(thread)**: 프로세스를 이루는 실행의 단위

메모리에 적재될 수 잇는 여러 프로세스에 필요한 자원을 할당하고, 스레드는 프로세스가 할당받은 자원을 이용해 프로세스의 작업을 수행함

운영체제는 동시다발적으로 실행되는 프로세스와 스레드가 올바르게 처리되도록 실행 순서 제어 및 프로세스와 스레드가 요구하는 자원을 적절하게 배분할 수 있어야 함

## 1.2 시스템 콜과 이중 모드

**커널 영역(kernel space)**
- 운영체제도 프로그램이기 때문에 적재되어야 하는데, 운영체제가 적재되는 별도의 공간
- 운영체제 기능을 제공받기 위해서는 커널 영역의 운영체제 코드를 실행해야 함

**사용자 영역(user space)**
- 운영체제가 적재되는 커널 영역 외에 사용자 응용 프로그램이 적재되는 공간

**응용 프로그램이 운영체제의 코드를 실행할 수 있는 방법**
- **시스템 콜(system call)** 호출
	- 운영체제의 서비스를 제공받기 위한 수단(인터페이스)
	- 호출 가능한 함수의 형태

**UNIX 계열 시스템 콜**

| 구분        | 시스템 콜     | 설명                  |
| --------- | --------- | ------------------- |
| 프로세스 관리   | fork()    | 새 자식 프로세스 생성        |
|           | execve()  | 프로세스 실행             |
|           | exit()    | 프로세스 종료             |
|           | waitpid() | 자식 프로세스가 종료할 때까지 대기 |
| 파일 관리     | open()    | 파일 열기               |
|           | close()   | 파일 닫기               |
|           | read()    | 파일 읽기               |
|           | write()   | 파일 쓰기               |
|           | stat()    | 파일 정보 획득            |
| 디렉터리 관리   | chdir()   | 작업 디렉터리 변경          |
|           | mkdir()   | 디렉터리 생성             |
|           | rmdir()   | 비어 있는 디렉터리 삭제       |
| 파일 시스템 관리 | mount()   | 파일 시스템 마운트          |
|           | umount()  | 파일 시스템 마운트 해제       |
> fork()를 통해 알 수 있듯이 프로세스는 시스템 콜을 통해 또 다른 프로세스를 생성할 수 있음


**시스템 콜에 의한 작업 수행 과정**
1. 소프트웨어 인터럽트 발생
	1. 입출력 명령어와 같이 명령어에 의해 발생하는 인터럽트
	2. 시스템 콜도 소프트웨어 인터럽트
2. CPU의 **커널 모드** 전환
	1. 커널 영역에 적재된 코드를 실행할 때의 실행모드
	2. 운영체제 서비스를 제공받을 수 있는 실행모드
3. 운영체제 코드 실행
4. **사용자 모드**로 재전환
	1. 사용자 영역에 적재된 코드를 실행할 때의 실행모드
	2. 운영체제 서비스를 제공받을 수 없는 실행모드

---
# 2. 프로세스와 스레드

## 2.1 **프로세스의 유형**
- **포그라운드 프로세스**
	- 사용자가 보는 공간에서 사용자와 상호작용하며 실행
- **백그라운드 프로세스**
	- 사용자가 보지 못하는 곳에서 실행
- **데몬**
	- 백그라운드 프로세스 중에서 사용자와 상호작용 없이 주어진 작업만 수행하는 프로세스
	- 윈도우에서는 서비스라고 함

## 2.2 **프로세스를 구성하는 메모리 내의 정보**
- **커널 영역**
	- **PCB(Process Control Block)**
		- 프로세스를 식별할 수 있는 커널 영역 내의 정보
		- 프로세스와 관련한 다양한 정보를 내포하는 구조체의 일종
		- 프로세스가 실행되면 커널에 만들어지고, 종료되면 폐기됨
		- 담기는 정보
			- PID
			- 실행 과정에서 사용한 레지스터 값
			- 프로세스 상태
			- CPU 스케줄링 정보
			- 메모리 관련 정보
			- 파일 및 입출력장치 관련 정보
		- 여러 PCB는 커널 내에 **프로세스 테이블** 형태로 관리되기도 함
			- 프로세스가 종료되었음에도 프로세스 테이블에 남아있는 경우 이 프로세스를 **좀비 프로세스**라고 함
- 사용자 영역
	- 코드 영역(code segment)
		- 실행 가능한 명령어가 저장되는 공간
		- 텍스트 영역(text segement)
		- CPU가 읽고 실행할 명령어가 있어 read-only
	- 데이터 영역(data segment)
		- 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
		- 정적변수, 전역 변수
		- BSS(Block Started by Symbol) 영역
			- 데이터 영역과 유사
			- 초깃값이 없는 데이터는 BSS 영역에 저장
	- 힙 영역(heap segment)
		- 프로그램을 만드는 사용자가 직접 할당 가능한 저장 공간
		- 힙 영역에 할당했으면 언젠가는 반환해야 함
		- 메모리 반환을 하지 않을 경우 메모리 누수(memory leak) 발생 가능
	- 스택 영역(stack segment)
		- 일시적으로 사용할 값들이 저장되는 공간
		- 매개변수, 지역 변수, 함수 복귀 주소 등
		- 스택 트레이스(stack trace)
			- 특정 시점에 스택 영역에 저장된 함수 호출 정보

## 2.3 컨텍스트 스위칭
> 메모리에 적재된 프로세스들은 한정된 시간 동안 번갈아 가며 실행됨

프로세스가 실행된다 = 운영체제의 의해 CPU 자원을 할당 받았다.

**타이머 인터럽트(timer interrupt)**
- 프로세스의 CPU 사용 시간은 타이머 인터럽트에 의해 제어
- 시간이 끝났음을 알리는 인터럽트
- 타임아웃 인터럽트

인터럽트가 발생한 경우
- 프로세스 A의 컨텍스트를 해당 프로세스의 PCB에 백업
	- PC, 레지스터, 메모리, 파일, ...
	- 이러한 중간 정보를 **문맥(context)** 이라고 함
	- 프로세스 문맥은 해당 프로세스의 PCB에 명시
- 프로세스 B의 컨텍스트 복구
- 위와 같은 과정을 **문맥 교환(context switching)** 이라고 함

잦은 문맥 교환은 캐시 미스 발생률이 올라갈 수 있어, 메모리 내용을 가져오는 작업이 빈번해짐에 따라 오버헤드로 이어질 수 있음

## 2.4 프로세스 상태

**생성 상태(new)**
- 프로세스 생성 중인 상태
- 메모리에 적재되어 PCB 할당 받음

**준비 상태(ready)**
- CPU를 할당받아 실행할 수 있지만, 자신의 차례가 아니라 기다리는 상태
- 준비 상태에서 실행 상태로 전환되는 것을 **디스패치(dispatch)**

**실행 상태(running)**
- CPU를 할당받아 실행 중인 상태

**대기 상태(blocked)**
- 입출력 작업 요청, 확보할 수 없는 자원 요청 등 곧장 실행이 불가능한 조건에 놓이는 경우 대기 상태가 됨
- 실행 가능한 상태가 되면 준비 상태로 변경

**종료 상태(terminated)**
- PCB와 프로세스가 사용한 메모리 정리

**블로킹 입출력과 논블로킹 입출력**
- 블로킹 입출력(blocking I/O)
	- 입출력 작업을 수행해야 할 때 대기 상태로 접어들고, 완료되면 준비 상태가 되어 실행 재개
- 논블로킹 입출력(non-blocking I/O)
	- 입출력장치에게 입출력 작업을 맡긴 뒤, 곧바로 이어질 명령어 실행

## 2.5 멀티프로세스와 멀티스레드


---
# 3. 동기화와 교착 상태


---
# 4. CPU 스케줄링


---
# 5. 가상 메모리


---
# 6. 파일 시스템
