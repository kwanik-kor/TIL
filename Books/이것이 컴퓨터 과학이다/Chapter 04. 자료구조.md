# 1. 자료구조의 큰 그림
## 1.1 자료구조와 알고리즘

**자료구조(data structure)**
- 어떤한 구조로 데이터를 다룰 것인가
- 데이터를 효율적으로 저장하고 관리하기 위한 방법

**알고리즘(algorithm)**
- 어떠한 목적을 이루기 위해 필요한 일련의 연산 절차

## 1.2 시간 복잡도와 공간 복잡도
> 소스 코드를 통해 다양한 데이터를 다루고(자료구조), 데이터를 활용해 특정 목적을 이루기 위한 연산(알고리즘)을 구현한다. 이 때, 고려여부에 따른 성능의 차이는 시간 복잡도와 공간 복잡도를 통해 표현할 수 있음

### 1.2.1 시간 복잡도(time complexity)
> 입력의 크기에 따른 프로그램 실행 시간의 관계

입력의 크기에 따른 프로그램 실행 시간이자, 입력의 크기에 따른 **연산횟수**라고 볼 수 있음

```python
# n 번의 연산
for _ in range(n):
 1 + 1

# 2n 번의 연산
for _ in range(2 * n):
 1 + 1

# n^2 번의 연산
for _ in range(n):
	for _ in range(n):
		1 + 1

```

하지만 입력의 크기가 결정된다고 해서 연산 횟수와 실행 시간이 무조건적으로 결정되지는 않는다. N 개의 데이터 중에서 특정 데이터를 찾는 프로그램이라 할 경우 100번 만에 찾을 수도 있고, 10000번 만에 찾을 수도 있기 때문.

### 1.2.2 빅 오 표기법(big O notation)
> 시간 복잡도를 표현하기 위한 가장 대중적인 방법으로, 함수의 **점근적 상한**을 표기

입력에 따른 실행 시간의 점근적 상한으로, n이 점점 증가해 무한대로 커진다고 해도 **실행 시간이 대략 이 이상(상한)은 커지지 않을 것**이라는 의미

- 빅 세타 표기법
	- 평균적인 실행 시간
	- 실행 시간의 증가율은 표기법과 같다
- 빅 오메가 표기법
	- 입력에 대한 실행 시간의 점근적 하한
	- 실행 시간의 증가율은 표기법보다 크다

최고차항의 차수만 고려하는데, 이는 n이 점점 무한대로 커진다면 계수와 낮은 차수의 항의 영향은 무시할 수 있게 되기 때문이다. 대표적인 시간 복잡도는 좋지 않은 것 순으로 아래와 같음
- O(n!)
- O(2^n)
- O(n^2)
- O(n log n)
- O(n)
- O(log n)
- O(1)

### 1.2.3 공간 복잡도(space complexity)
프로그램이 실행되었을 때 필요한 메모리 자원의 양으로 입력에 따른 메모리 사용량의 척도. 공간 복잡도 또한 시간 복잡도처럼 빅 오 표기법으로 표현하며 이는 입력에 따라 필요한 메모리 자원의 양에 대한 점근적 상한을 의미함. 하지만, 오늘날에는 공간 복잡도 보다는 시간 복잡도로 주로 표현함에 따라, 대부분의 표기법은 시간 복잡도를 의미함

# 2. 배열과 연결 리스트

> 가장 기본적인 자료구조

## 2.1 배열(array)
> 일정한 메모리 공간을 차지하는 여러 요소들이 순차적으로 나열된 자료구조

각 요소는 0부터 시작하는 고유한 순서 번호인 **인덱스(index)** 가 매겨지며, 인덱스로 배열의 요소를 식별할 수 있다. RAM과 같이 배열 역시 인덱스를 통해 요소를 접근할 때 개수와 무관하게 일정한 시간(O(1))이 걸린다.

- 인덱스를 통해 요소에 접근
	- O(1)
- 데이터 탐색
	- O(n)
- 데이터 삽입/삭제
	- O(n)
	- 중간에 추가/삭제된 요소로 인해 다른 이후의 요소들이 이동되어야 하기 때문

### 2.1.1 정적 배열과 동적 배열

**정적 배열(static array)**
- 프로그램을 실행하기 전에 크기가 고정되어 있는 배열
- 원칙적으로 프로그램 실행 도중에 바꿀 수 없음

**동적 배열(dynamic array)**
- 실행 과정에서 크기가 변할 수 있는 배열
- 벡터(vector)

## 2.2 연결 리스트(Linked List)
> 노드의 모음으로 구성된 자료구조

**노드(node)**
- 저장하고자 하는 데이터
- 다음 노드의 위치(메모리 상의 주소)
- 헤드(head)
	- 연결 리스트의 첫 번째 노드
- 꼬리(tail)
	- 연결 리스트의 마지막 노드

연결 리스트를 구성하는 노드는 순차적으로 저장되어 있을 필요가 없음에 따라, 연속적으로 구성되어 있는 데이터를 불연속적으로 저장할 때 유용하게 사용할 수 있음
- 특정 요소에 접근
	- O(n)
- 데이터 삽입/삭제
	- O(1)

**이중 연결 리스트(doubly linked list)**
- 다음 노드와 **이전 노드**의 위치 정보를 함께 가지고 있음\
- 싱글 연결 리스트의 탐색 성능을 어느 정도 보완할 수 있지만, 데이터 저장 공간이 더 필요함

**환형 연결 리스트(circular linked list, 원형 연결 리스트)**
- 꼬리 노드가 헤드 노드를 가리켜 노드가 원형으로 구성
- 이중 연결 리스트로도 구현 가능