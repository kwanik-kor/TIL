# 3.1 네트워크의 공통 언어
> 프로토콜: PC, 스마트폰 등이 통신하는 규칙

- 여러 네트워크 아키텍처중 현재는 TCP/IP만 거의 사용함
	- TCP/IP로 통신하는 네트워크 기기 전반을 **호스트(host)**라고 함

**TCP/IP**
- 애플리케이션층
	- 애플리케이션에서 다룰 데이터 형식과 절차 결정
	- HTTP, SMTP, POP3, IMAP4, DHCP, DNS
- 트랜스포트층
	- 애플리케이션에 데이터를 할당
	- TCP, UDP
- 인터넷층
	- 엔드투엔드 통신
	- IP, ICMP, ARP
- 네트워크 인터페이스층
	- 프로토콜은 자유롭게 선택할 수 있음
	- 통신상대와 동일한 것을 사용할 필요 X
	- 이더넷, 무선 LAN, PPP 등

4개 계층의 프로토콜이 모두 정상적으로 제기능을 해야 통신이 이루어짐

# 3.2 데이터를 전송하는 역할을 하는 계층

### 3.2.1 네트워크 인터페이스층
> 같은 네트워크 안에서 데이터를 전송하는 것

- 하나의 네트워크는 라우터와 레이어3 스위치로 구획되는 범위 또는 레이어2 스위치로 구성하는 범위
- 레이어2 스위치에 연결된 PC에서 같은 레이어2 스위치에 연결된 다른 PC의 인터페이스까지 데이터를 전송하는 것
- 0,1 디지털 데이터를 전기신호 등의 물리적 신호로 변환해 전송매체로 전달
- 이더넷, 무선 LAN, PPP

### 3.2.2 인터넷층
> 네트워크 사이에서 데이터를 전송하는 역할

- 라우터
	- 네트워크끼리 연결하고 데이터를 전송하는 기기
	- 라우팅: 라우터에 의한 네트워크 간 전송
- 엔드투엔드 통신
	- 원격지 네트워크에서 최종적인 출발지와 목적지 사이의 데이터 전송
- IP, ICMP, ARP
	- ICMP와 ARP는 IP를 보조하는 프로토콜

# 3.3 애플리케이션의 동작을 준비하는 계층

### 3.3.1 트랜스포트층
> 데이터를 적절한 애플리케이션에 배분하는 역할

- 최하층부터 트랜스포트층까지 바르게 동작하면 출발지와 목적지 애플리케이션 간에 데이터를 송수신할 수 있게 됨
- TCP, UDP
- TCP를 이용할 경우, 데이터가 유실되더라도 그 사실을 검출해 데이터를 다시 보내붐
	- 엔드투엔드의 신뢰성을  확보해 주는 기능이 있음
- 데이터 분할, 조립
### 3.3.2 애플리케이션층
> 애플리케이션의 기능을 실행하기 위한 데이터의 형식과 처리 절차 등을 결정하는 것

- 문자와 이미지 등 인간이 인식할 수 있도록 데이터 표현
- HTTP, SMTP, POP3, DHCP, DNS
- DHCP, DNS는 애플리케이션의 통신을 준비하기 위한 프로토콜

# 3.4 데이터 송수신 규칙
> TCP/IP는 네 개의 프로토콜을 조합하여 데이터를 주고 받음

- **헤더(header)**
	- 각각의 기능을 실현하기 위한 제어 정보
	- **캡슐화**
		- 각 프로토콜은 데이터를 전송할 때 헤더를 추가함
	- **역캡슐화, 비캡슐화**
		- 프로토콜이 헤더를 바탕으로 적절하게 처리하여 헤더를 벗겨내고 다시 다른 프로토콜로 처리를 넘김

- 웹브라우저에서 웹서버 애플리케이션으로 데이터 송신, 전송하는 경우
	- HTTP 헤더 + 데이터
	- TCP 헤더 + HTTP 헤더 + 데이터
	- IP 헤더 + TCP 헤더 + HTTP 헤더 + 데이터
	- 이더넷 헤더 +IP 헤더 + TCP 헤더 + HTTP 헤더 + 데이터 + FCS
	- 이더넷 규격에 대응하여 물리적인 신호로 변환해 전송 매체로 내보냄
- **FCS(Frame Check Sequence)**
	- 에러 체크를 위한 정보

# 3.5 데이터 수신, 전송할 때의 규칙
> 네트워크 기기는 수신한 물리적인 신호를 일단 0과 1의 데이터로 되돌림

- 물리적인 신호가 도착하는 경우
	- 0과 1의 데이터로 변환
	- 이더넷 헤더를 참조해 자기 앞으로 온 데이터인지 확인
	- FCS로 데이터에 오류가 없는지 확인
	- 이더넷 헤더와 FCS를 제거하고 IP 헤더 처리를 넘김
	- IP 헤더를 참조해 자기 앞으로 온 데이터인지 확인
	- IP 헤더를 제거하고 TCP 헤더 처리를 넘김
	- TCP 헤더를 참조해 어느 애플리케이션의 데이터인지 확인
	- HTTP 헤더와 그 뒤의 데이터 부분을 처리

# 3.6 데이터를 부르는 방법은 다양하다
> 계층별로 데이터를 부르는 방법이 서로 다름

- 애플리케이션층: 메시지
	- HTTP 메시지
- 트랜스포트층: TCP - 새그먼트 / UDP - 데이터그램
	- TCP 세그먼트
- 인터넷층: 패킷 또는 데이터그램
	- IP 패킷
	- 라우터
- 네트워크 인터페이스층: 프레임
	- 이더넷 프레임
	- 레이어2 스위치

# 3.7 데이터를 목적지까지 전송한다
> IP(Internet Protocol)

- 엔드투엔드 통신
	- 어떤 PC에서 다른 PC 등으로 데이터를 전송하는 역할

- IP로 데이터 전송을 위해서는 데이터에 IP 헤더를 추가해 IP 패킷을 만들어야 함
- IP 주소가 가장 중요
	- 데이터의 출발지와 목적지를 나타내기 때문
- 목적지가 다른 네트워크에 접속된 경우는 중간에 라우터가 라우팅을 해줌

- **IP 패킷 - 20 Byte**
	- 버전(4), 헤더길이(4), 서비스타입(8), 패킷 길이(16)
	- 식별번호(16), 플래그(3), 프래그먼트 오프셋(13)
	- TTL(8), 프로토콜번호(8), 헤더 체크섬(16)
	- 출발지 IP 주소(32)
	- 목적지 IP 주소(32)
	- 옵션, 패딩

# 3.8 통신 상대는 누구?

**IP 주소**
- 통신 상대가 되는 호스트를 식별하기 위한 식별 정보
- 통신을 위해서는 IP 주소를 반드시 지정해야 함
- 이더넷 등의 인터페이스와 연관지어 설정함
	- IP 프로토콜은 호스트의 운영체제에서 동작
	- 호스트 내부에서 인터페이스와 IP의 프로토콜 부분을 연관 지어 설정
- 호스트 자체가 아닌 호스트의 인터페이스를 식별하는 것
- 32비트의 주소를 8비트씩 10진수로 변환하여 표기
	- 도트형 10진 표기

# 3.9 목적지는 하나? 아니면 여러 개?

**유니캐스트(Unicast)**
- 단 한 곳으로 데이터를 전송하는 것
- 유니캐스트 IP
	- 유니캐스트에 이용하는 IP 주소
- 목적지 호스트의 유니캐스트 IP 주소를 IP 헤더의 목적지 IP 주소로 지정

**브로드캐스트(Broadcast)**
- 같은 네트워크 상의 모든 호스트에게 완전히 똑같은 데이터를 전송하는 것

**멀티캐스트(Multicast)**
- 특정 그룹에 포함되는 멀티캐스트 그룹에 완전히 똑같은 데이터를 전송하는 것

# 3.10 IP 주소의 구성은 크게 나눠 두 가지
> IP 주소는 네트워크부와 호스트부 두 개의 부분으로 구성됨

**네트워크부**
- IP 주소 전반의 네트워크부로 각 네트워크를 식별함

호스트부
- 후반의 호스트부로 네트워크 내 호스트(의 인터페이스)를 식별함

**브로드캐스트 IP 주소**
- 같은 네트워크에 있는 모든 호스트에 일괄적으로 데이터를 전송할 때 사용
- 32비트가 모두 1인 IP
	- 255.255.255.255
	- 유니캐스트 IP 주소 후반 호스트부의 모든 비트가 1로된 IP 주소도 브로드캐스트

**멀티캐스트 IP 주소**
- 224.0.0.0 ~ 239.255.255.255 로 범위가 정해져 있음
- 일부는 미리 정해져 있음
	- 224.0.0.2: 같은 네트워크 상의 모든 라우터
	- 사용자가 자유롭게 그룹을 결정하기 위해서 239로 시작되는 범위 이용 가능

# 3.11 IP 주소의 범위 구분

**서브넷 마스크**
- 네트워크부와 호스트부의 구분은 고정되지 않고 가변적임
- 32비트 IP주소의 어디까지가 네트워크부인지를 명시한 것이 서브넷 마스크!!
- IP 주소와 마찬가지로 8비트씩 끊어 10진수로 변환하여 표기함
- / 뒤에 연속된 1의 개수로 표기하는 경우도 있음
	- 192.168.1.1 255.255.255.0
	- 192.168.1.1/24

- IP 후반 호스트부를 모두 0으로 채우게 되면 네트워크 주소
- 모두 1로 채우게 되면 브로드캐스트 주소

# 3.12 네트워크에 접속하는 두 단계

**물리적인 접속**
- 네트워크 인터페이스층
- 물리적인 신호를 주고받을 수 있게 하는 것
	- 이더넷의 인터페이스에 LAN 케이블을 삽입
	- 무선 LAN 액세스 포인트에 접속
	- 휴대전화 기지국 전파 포착

**논리적인 접속**
- 인터넷층
- 논리적인 접속을 위해 IP 주소 설정이 필요
- IP 주소가 없으면 통신할 수 없음
- DHCP 기술로 자동으로 설정할 수 있게됨
- 인터페이스에 IP 주소를 설정하는 것

# 3.13 인터넷에서 사용하는 주소와 사설 네트워크에서 사용하는 주소
> IP 주소는 이용 범위에 따라 공인 IP 주소(퍼블릭 IP 주소)와 사설 IP로 분류

**공인 IP 주소(public IP address)**
- 인터넷에서 통신하기 위해서는 반드시 필요
- 인터넷 전체에서 중복되지 않도록 관리

**사설 IP 주소(private IP address)**
- 사내 네트워크 등 사설 네트워크에서 이용하는 IP
- 할당된 주소 범위
	- 10.0.0.0 ~ 10.255.255.255
	- 172.16.0.0 ~ 172.31.255.255
	- 192.168.0.0 ~ 192.168.255.255
- 다른 사설 네트워크의 IP 주소와 겹쳐도 사설 네트워크 안의 통신에는 문제가 없음

# 3.14 사설 네트워크에서 인터넷으로의 통신
> 사설 IP를 사용하는 네트워크에서 인터넷으로 통신할 때는 사설 주소 그대로 사용할 수 없음. 이를 위해서는 NAT(Network Address Translation)가 필요함

- 사설 네트워크 PC에서 인터넷 서버에 요청을 보내면 목적지는 공인 주소고 출발지는 사설 네트워크임
	- 이 요청은 보낼 수 있지만 응답을 받을 수는 없음
	- 인터넷에서는 목적지가 사설 주소로 된 IP 패킷은 반드시 폐기되기 때문

- **NAT를 통한 주소 변환 과정**
	- 사설 네트워크에서 인터넷으로 요청할 때 출발지 IP 주소를 변환함
	- 라우터는 나중에 원래대로 돌리기 위해 변환한 주소의 대응을 NAT 테이블에 보존해둠
	- 요청에 대한 응답이 라우터로 돌아오면, 목적지 IP 주소를 변환함. 이 때 NAT 테이블에 보존해 둔 주소의 대응을 이용

- **NAPT(Network Address Port Translation)**
	- 복수의 사설 주소를 하나의 글로벌 주소에 대응시키는 것
	- 사설 주소와 공인 주소를 1:1로 대응하기 위해서는 공인주소가 많이 필요하기 때문

# 3.15 데이터가 목적지에 잘 도착했을까?
> IP는 데이터가 제대로 도착했는가 확인하는 방법이 없음

- IP는 데이터에 IP 헤더를 붙여 IP 패킷으로 만들어 네트워크 상에 보내기만 할 뿐
- **최선형(best effort)**
	- 데이터를 보내기 위해 최선을 다하지만, 안되도 어쩔 수 없음

**ICMP(Internet Control Message Protocol)**
- IP에 의한 엔드투엔드 통신이 정상적으로 이루어졌는지 확인하는 기능을 갖춘 프로토콜
	- 에러 리포트
		- IP 패킷을 폐기하면, 폐기한 기기가 ICMP를 이용해 폐기한 IP 패킷의 출발지로 에러 리포트 전송
		- 도달불능 메시지
	- 진단 기능
		- 엔드투엔드 통신이 가능한지 확인하는 기능
		- ping 커맨드

# 3.16 IP 주소와 MAC 주소를 대응시킨다
> IP 주소를 지정하여 전송된 IP 패킷은 PC나 서버 등의 인터페이스까지 전송되며, 이 인터페이스는 MAC 주소로 식별함

**ARP(Address Resolution Protocol)**
- IP 주소와 인터페이스를 식별하기 위한 주소인 MAC 주소를 대응시키는 역할
- 이더넷 헤더에는 목적지 MAC 주소를 지정해야 함
- 목적지 IP주소에 대응하는 MAC 주소를 구하기 위해 ARP를 사용함
- 같은 네트워크 내의 IP 주소가 해석 범위

**ARP 동작 흐름**
- ARP 요청으로 IP 주소에 대응하는 MAC 주소를 질의(브로드캐스트)
- 질의받은 IP 주소를 가진 호스트가 ARP 응답으로 MAC 주소를 알려줌
- 주소 해석한 IP 주소와 MAC 주소의 대응을 ARP 캐시에 보존

# 3.17 포트 번호로 애플리케이션에 할당한다
> 호스트에서 동작하는 애플리케이션에 데이터를 배분하기 위해서는 각각의 애플리케이션을 식별할 수 있어야 함

**포트 번호(port)**
- TCP/IP의 애플리케이션을 식별하는 식별 번호
- TCP 또는 UDP 헤더 지정
- 16비트, 0 ~ 65535까지 지정 가능

**웰노운 포트(well-known port)**
- 미리 정해져 있는 포트 번호
- 서버 애플리케이션 실행 시, 웰노운 포트 번호로 클라이언트 애플리케이션의 요청을 기다림
	- 0 ~ 1023 : 서버 애플리케이션용으로 예약된 번호
		- HTTP: 80
		- HTTPS: 443
		- SMTP: 25
		- POP3: 110
		- IMAP4: 143
		- FTP: 20/21
		- DHCP: 67/68(UDP)
	- 1024 ~ 49151 : 자주 이용되는 애플리케이션의 서버 쪽 포트 번호
	- 49152 ~ 65535 : 클라이언트 애플리케이션용 포트 번호

**등록된 포트(registered port)**
- 웰노운 포트 이외에 자주 이용되는 서버 애플리케이션을 식별하기 위한 포트 번호

동적/사설 포트
- 클라이언트 애플리케이션을 식별하기 위한 포트 번호
- 애플리케이션이 통신할 때 동적으로 할당

# 3.18 확실하게 애플리케이션의 데이터를 전송한다

**TCP(Transmission Control Protocol)**
- 신뢰성이 있는 애플리케이션 간의 데이터 전송을 하기 위한 프로토콜
- 애플리케이션 프로토콜에는 신뢰성을 확보하기 위한 구조를 넣을 필요가 없음
- 전송 절차
	- TCP 커넥션 맺기
		- 송수신 애플리케애션 간의 통신이 정상으로 이루어질 수 있는지 확인
			- 3웨이 핸드쉐이크(3-way handshake)
	- 애플리케이션 간 데이터 송수신
		- 데이터 송신
			- 애플리케이션 데이터에 프로토콜 헤더와 TCP 헤더 추가
				- TCP 세그먼트
			- 애플리케이션 데이터가 큰 경우 복수의 TCP 세그먼트로써 전송
			- 어떻게 분할했는지는 TCP 헤더에 기술, 목적지에서 차례대로 조립
		- 데이터 수신
			- 수신이 되면 확인을 해줌
				- ACK
			- 일부 제대로 도착하지 않았다면 재전송
			- 네트워크가 혼잡하다면 데이터 전송 속도 제한
			- **플로우 제어**
	- TCP 커넥션 끊기

# 3.19 TCP로 데이터를 분할한다

**TCP 헤더 형식**
- 출발지 포트 번호(16) + 목적지 포트 번호(16)
- 시퀀스 번호(32)
	- TCP로 전송하는 데이터 순서
- ACK 번호(32)
	- 데이터를 바르게 수신했음을 확인하기 위해 사용
- 데이터 세그먼트(4) + 예약(6) + 플래그(6) + 윈도우 사이즈(16)
- 체크섬(16) + 에이전트 포인터(16)

TCP 헤더에서 가장 중요한 것은 포트 번호
- 포트 번호로 적절한 애플리케이션 프로토콜에 데이터를 분배할 수 있기 때문
- 시퀀스 번호, ACK 번호
	- 신뢰성 있는 데이터 전송을 위해 필요

**데이터 분할 기능**
- **MSS(Maximum Segment Size)** 단위로 분할
	- 표준 크기: 1460 바이트
	- 이를 넘는 크기의 데이터는 MSS 단위로 나누어 TCP 헤더를 붙여 전송

# 3.20 애플리케이션에 데이터를 배분하기만 한다

**UDP(User Datagram Protocol)**
- PC나 서버 등에 도달한 데이터를 적절한 애플리케이션에 배분하는 기능만 있음
- UDP 헤더 + 애플리케이션 데이터 = UDP 데이터그램

UDP 헤더 형식
- 출발지 포트 번호(16) + 도착지 포트 번호(16)
- 데이터그램 길이(16) + 체크섬(16)

**특징**
- 상대방의 동작을 확인하지 않을 채 무조건 UDP 데이터그램으로 애플리케이션의 데이터 송신
- TCP와 같이 여분의 처리를 하지 않으므로 전송 효율이 좋음
- 단, 신뢰성이 높지 않음
- 크기가 큰 데이터를 분할하는 기능도 없음
- IP 전화
	- IP 전화의 음성 데이터는 IP 전화에서 작게 쪼갬
	- 쪼개진 데이터에 UDP 헤더를 추가해서 전송

# 3.21 네트워크의 전화번호부
> TCP/IP로 통신할 때는 통신 상대방의 IP 주소를 반드시 지정해야 하지만, 애플리케이션을 이용하는 사용자가 IP 주소를 이해하기는 어려움

- 애플리케이션이 동작하는 서버는 클라이언트 PC 등의 호스트에 사용자가 이해하기 쉬운 이름인 **호스트명**을 붙임
	- URL, 메일 주소
- 호스트 이름에 대응하는 IP 주소를 자동으로 구하는 것이 **DNS**의 역할
	- 이름해석: 호스트명에서 IP 주소를 구하는 방법

# 3.22 DNS로 IP 주소를 자동으로 구한다
> DNS 이용을 위해서는 DNS 서버가 필요

- DNS 서버에 호스트명과 IP 주소의 대응 관계를 등록해둠
	- 이 외의 부가적인 정보도 등록함
		- **리소스 레코드(resource record)**
			- A: 호스트명에 대응하는 IP 주소
			- AAAA: 호스트명에 대응하는 IPv6 주소
			- CNAME: 호스트명에 대응하는 별명
			- MX: 도메인명에 대응하는 메일 서버
			- NS: 도메인명을 관리하는 DNS 서버
			- PTR: IP 주소에 대응하는 호스트명
	- 루트를 정점으로 한 계층 구조로 구성되어 있음

**DNS 이름해석 원리**
- 호스트는 DNS 서버의 IP 주소를 설정해둠
- 사용자가 호스트 이름을 지정하면, 자동으로 DNS 서버에 대응하는 IP 주소를 질의
- DNS 서버에 질의하는 기능을 **DNS 리졸버**라고 함
- 본인의 도메인 이외의 호스트명을 찾으려면 루트에서부터 더듬어가며 여러번 질의를 반복함
	- 재귀질의
- DNS 서버와 리졸버는 질의한 정보를 한동안 캐시에 보관

# 3.23 필요한 설정을 자동화한다
> TCP/IP를 이용해 통신하기 위해서는 PC/스마트폰, 서버, 각종 네트워크 기기에 TCP/IP 설정이 바르게 되어 있어야 함

**DHCP(Dynamic Host Configuration Protocol)**
- 설정을 자동화하는 프로토콜
- DHCP 서버를 통해 할당할 IP 주소 등 TCP/IP 설정을 등록
- PC 등에서 DHCP 클라이언트가 되도록 설정
- 클라이언트가 호스트에 접속하면, DHCP와 아래의 메시지를 주고 받음
	- DHCP DISCOVER
		- DHCP 서버가 있나요? 있으면 사용할 수 있는 TCP/IP 설정을 알려주세요.
	- DHCP OFFER
		- 사용할 수 있는 TCP/IP 설정은 이것입니다. 어떤가요?
	- DHCP REQUEST
		- 그럼 그 설정 정보 사용하게 해주세요.
	- DHCP ACK
		- OK
- 브로드캐스트 사용

