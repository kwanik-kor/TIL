# 1. 동기 vs 비동기
### 1.1 동기(Synchronous)

- 요청한 작업에 대해 완료 여부를 따져 순차대로 처리
- 요청한 작업에 대해 순서가 지켜지는 것

### 1.2 비동기(Asynchronous)

- 요청한 작업에 대해 완료 여부를 따지지 않기 때문에 다음 작업을 그대로 수행
- 요청한 작업에 대해 순서가 지켜지지 않을 수 있다는 것

# 2. 블로킹 vs 논 블로킹
## 2.1 블로킹(Blocking I/O)

- 하나의 스레드가 I/O에 의해서 차단되어 대기하는 것
	- 이 방식을 보완하기 위해 멀티스레딩 기법으로 추가 스레드를 할당하여 차단된 시간을 효율적으로 사용하고자 함
	- 멀티스레딩의 문제점
		- 컨텍스트 스위칭으로 인한 스레드 전환 비용 발생
			- PCB(Process Control Block)에 실행되던 프로세스 내용을 저장, 불러오는 과정
			- 즉각 재실행되는 것이 아니라, reload 하는 유휴 시간(Idle time)이 발생하기 때문
		- 과다한 메모리 사용으로 오버헤드가 발생할 수 있음
			- 새로운 스레드 시작 시, JVM은 해당 스레드를 위한 스택 영역 일부를 할당하며, 새로운 스레드 정보는 스택 영역에 개별 프레임의 형태로 저장됨
			- 스레드 내부에서 또 다른 작업 처리를 위한 스레드를 할당하게 되면 메모리 사용량이 과도하게 증가하게 됨
		- 스레드 풀에서 응답 지연이 발생할 수 있음
		- 유휴 스레드가 없을 경우 사용 가능한 스레드가 확보되기 전까지 응답 지연 발생

## 2.2 논 블로킹(Non-Blocking I/O)

- 작업 스레드의 종료 여부와 관계없이 요청한 스레드는 차단되지 않음
	- 스레드가 차단되지 않기 때문에 하나의 스레드로 많은 요청을 처리할 수 있음
	- 블로킹 방식의 멀티스레딩의 문제가 발생하지 않음
	- 단점
		- CPU를 많이 사용하는 작업이 포함된 경우 성능에 악영향
		- 요청에서 응답까지의 과정에서 Blocking I/O 요소가 포함된 경우 이점을 발휘하기 어려움

## 2.3 Spring Framework에서의 블로킹과 논블로킹

- Spring MVC
	- 블로킹 I/O 방식 사용
	- Servlet Container 기반으로,  요청당 하나의 스레드 사용
	- 대량의 요청을 처리하기 위해 과도한 스레드 사용
- Spring WebFlux
	- 논블로킹 I/O 방식 사용
	- Netty 기반의 논블로킹 I/O 서버 엔진 사용


---
### 궁금증

1. Spring MVC의 기본적인 스레드 개수가 어떻게 되지?

---

RPS
응답속도가 튀지 않게 만들어주는 것
성능 모니터링
- 평균 응답 속도
- 95, 99%

----

- Future, CompletableFuture
- Blocking, Non-Blocking
	- 운영체제에서의 블로킹


핵심은 한정된 자원을 효과적, 효율적으로 쓰는 것
sync, async 로직과 스레드의 관계