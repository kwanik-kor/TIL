# 1. 컴퓨터 구조의 큰 그림


---
# 2. 컴퓨터가 이해하는 정보
> 0과 1만 이해하는 컴퓨터가 문자와 숫자를 인식하는 방법, 표현된 정적인 데이터가 명령어에 대해 어떻게 실행되는지

- 비트(bit): 정보를 표현하는 가장 작은 단위
- 워드(word): CPU 관점에서의 정보 단위로, CPU가 한 번에 처리할 수 있는 데이터의 크기
	- CPU가 한 번에 32비트를 처리할 수 있다면 1워드 = 32비트

## 2.1 데이터 - 0과 1로 숫자 표현하기

- CPU는 0과 1만 이해할 수 있으며 컴퓨터는 2진법을 사용
- **소수 표현**
	- 표현하고자 하는 소수와 실제로 저장된 소수 간의 오차가 발생할 수 있음
	- **부동 소수점(IEEE 754)**
		- 필요에 따라 소수점의 위치가 이동할 수 있음
		- m x 2^n
			- m : 가수(significant)
			- n : 지수(exponent)
		- 부호 비트 + 지수 비트 + 가수 비트
			- 32 비트 : 1 + 8 + 23
			- 64 비트 : 1 + 11 + 52
		- 가수는 1.XXX 형태로 1로 **정규화한 수를 저장**
		- 1.1010111010101 x 2^6
			- 지수 : 바이어스(bias) + 6
				- **바이어스**: 2^(k - 1) - 1
			- 가수 : 1010111010101 저장
```Java
var a = 0.1;  
var b = 0.2;  
var c = 0.3;  
  
if (a + b == c) {  
    System.out.println("equal");  
} else {
	// here works!
    System.out.println("not equal");  
}
```

## 2.2 데이터 - 0과 1로 문자 표현하기

- 문자 집합(Character set): 컴퓨터가 이해할 수 있는 문자들의 집합
	- 문자 인코딩(Character Encoding): 문자 집합 속 문자를 0과 1로 이루어진 문자 코드로 변환하는 과정
	- 문자 디코딩(Character Decoding): 0과 1로 표현된 문자를 사람이 이해하는 문자로 변환하는 과정

- **ASCII(American Standard Code for Information Interchange)**
	- 영어, 알파벳, 아라비아 숫자, 일부 특수문자
	- 8비트(1 Byte)
		- 그 중 1 비트는 **패리티 비트**로 오류 검출용 비트
		- 실질적으로는 7비트로써 128개의 문자 표현
	- 코드 포인트(Code Point)
		- 글자에 부여된 고유한 값
		- A : 65
		- a : 97
	- 한글 표현 X

- **EUC-KR**
	- 아스키 문자 : 1 바이트
	- 하나의 한글 글자 : 2 바이트
		- 네 자리 16진수로 표현
	- ex1) 한 : c7d1
	- ex2) 글 : b1db
	- 일부 한글 문자 표현할 수 없음
	- 글자에 부여된 값을 그대로 인코딩 값으로 사용

- **유니코드(Unicode)**
	- 훨씬 많은 언어, 특수문자, 화살표, 이모티콘까지 표현할 수 있는 통일된 문자 집합
		- ex1) 한: 0xd55c
		- ex2) 글: 0xae00
	- 인코딩 방법 존재
		- 가변 길이 인코딩
			- 인코딩된 결과의 길이가 일정하지 않을 수 있음
			- UTF-8
			- UTF-16
			- UTF-32
		- base64
			- 이진 데이터까지 변환할 수 있는 인코딩 방식
			- 64진법
			- 변환할 데이터를 6비트씩 나누어 4개씩(24비트씩) 한번에 변환
			- 나누어 떨어지지 않는 자리는 0으로 채워 패딩(padding)이 되고 =으로 표기

## 2.3 명령어

- 명령어 : **수행할 동작**과 **수행할 대상**으로 구성
	- **연산 코드(opcode)** : 수행할 동작
		- CPU에 따라 연산코드의 구체적인 생김새가 다르지만, 공통적인 유형 존재
	- **오퍼랜드(operand)** : 수행할 대상
		- 데이터 자체
		- 데이터가 저장된 위치
			- 대부분 데이터가 저장된 위치(메모리 주소, 레지스터 이름)가 명시됨
			- 주소 필드(address field)라고도 부름

- 대표적인 연산코드 유형

| 유형       | 연산코드                         | 설명                               |
| -------- | ---------------------------- | -------------------------------- |
| 데이터 전송   | MOVE                         | 데이터를 옮겨라                         |
|          | STORE                        | 메모리에 저장해라                        |
|          | LOAD(FETCH)                  | 데이터를 메모리에서 CPU로 가져와라             |
|          | PUSH                         | 데이터를 스택에 저장하라                    |
|          | POP                          | 스택의 최상단 데이터를 가져와라                |
| 산술/논리 연산 | ADD/SUBTRACT/MULTIPLY/DIVIDE | 덧셈/뺄셈/곱셈/나눗셈을 수행하라               |
|          | INCREMENT/DECREMENT          | 오퍼랜드에 1을 더해라<br>오퍼랜드에서 1을 빼라     |
|          | AND/OR/NOT                   | AND/OR/NOT 연산을 수행해라              |
|          | COMPARE                      | 두 개의 숫자, 혹은 true/false를 비교해라     |
| 제어 흐름 변경 | JUMP                         | 특정 주소로 실행 순서를 옮겨라                |
|          | CONDITIONAL JUMP             | 조건에 부합할 경우 특정 주소로 실행 순서를 옮겨라     |
|          | HALT                         | 프로그램의 실행을 멈춰라                    |
|          | CALL                         | 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라 |
|          | RETURN                       | CALL을 호출할 때 저장했던 주소로 돌아가라        |
| 입출력 제어   | READ(INPUT)                  | 특정 입출력장치로부터 데이터를 읽어라             |
|          | WRITE(OUTPUT)                | 특정 입출력장치로 데이터를 써라                |
|          | START IO                     | 입출력장치를 시작해라                      |
|          | TEST IO                      | 입출력장치의 현재 상태를 확인해라               |

- 기계어(machine code)
	- CPU가 이해할 수 있도록 0과 1로 표현된 정보를 있는 그대로 표현한 언어
- 어셈블리어(assembly language)
	- 0과 1로 표현된 기계어를 읽기 편한 형태로 단순 번역한 언어

- **명령어 사이클(instruction cycle)**
	- CPU가 명령어를 처리하는 과정에는 정형화된 흐름이 있으며, 이 흐름 속에서 프로그램 속 각각의 명령어들은 일정한 주기를 반복하며 실행되는데, 이 주기를 명령어 사이클이라 함
	- **인출 사이클(fetch cycle)**
		- 첫 번째 과정
		- 메모리에 있는 명령어를 CPU로 가져옴
	- **실행 사이클(execution cycle)**
		- CPU로 가져온 명령어를 실행하는 단계
	- **간접 사이클(indirect cycle)**
		- 명령어를 실행하기 위해 한 번 더 메모리에 접근하는 단계
	- **인터럽트 사이클(interrupt cycle)**
		- 

---
# 3. CPU


---

# 4. 메모리

# 5. 보조기억장치와 입출력장치