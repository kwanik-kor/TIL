> 2022년 11월 28일(월) 10:30 - Chapter 24

# Chapter 24. 지속적 배포
> 빠르게 변하는 기술 환경에 따라, 제품이 경쟁력을 갖추기 위해서는 시장에 신속하게 출시할 수 있는 능력이 중요하다. 즉, 유사 서비스와의
> 경쟁, 제품과 서비스 품질 유지, 새로운 규제에의 적응에 내 조직의 속도가 더욱 중요한 요인이 된 것!
> 
> 이 과정에서 배포 시간이 속도의 발목을 잡을 수 있다.

- 오랜 기간 성공적으로 살아남은 조직들은 '하나같이 아이디어를 빠르게 실천하고 고객의 손에 최대한 빨리 전달하고 그들의 피드백에 신속하게 대응하는 능력'을 갖춤

### 24.1 지속적 배포 이디엄 @구글
> **지속적 배포(continuous delivery)** 그리고 애자일 방법론의 핵심은 작은 변경들을 자주 배포할 수록 품질이 높아진다는 것이다.

- CD라는 최종 목표에 닿기 위한 독립적인 가치들
  - **민첩성**: 자주, 작게 릴리스한다.
  - **자동화**: 잦은 릴리스에 수반되는 반복 작업 부담을 줄이거나 없앤다.
  - **격리**: 변경을 격리하여 문제를 쉽게 해결할 수 있도록 모듈화된 아키텍처를 지향한다.
  - **신뢰성**: 비정상 종료와 지연시간 같은 주요 상태 지표를 측정하고 꾸준히 개선한다.
  - **데이터 중심 의사 결정**: A/B 실험으로 상태 지표를 비교하여 품질을 높인다.
  - **단계적 출시**: 변경을 모두에게 동시에 출시하지 않고 소수의 사용자부터 이용해보게 한다.
- 일하는 문화를 **지속적 배포**로 가는 중간 형태로 바꿔서 자심감을 키우자!

---
### 24.2 속도는 팀 스포츠다: 배포를 관리 가능한 조각으로 나누기
> 팀이 작을 때는 일정한 속도로 코드베이스에 변경들이 도달하지만, 팀이 커지거나 하위 팀으로 쪼개지면서 안티패턴들이 등장한다.
> 
> 구글은 모든 팀이 같은 코드베이스의 헤드에서 개발하는 쪽을 선호한다.

- 릴리스 운영비가 치솟을수록 프로세스는 더 어려워지고 오류가 많아지고 느려진다.
  - '본능적'으로 릴리스 주기를 늦춰 안정성을 확보할 기간을 늘리려고 한다.

> 이것은 팀의 속도가 느려지고 팀과 고객 모두를 좌절시키는 선택이다.

- 정답은 비용을 줄이고, 규율을 강화하고, 위험에 점진적으로 대응하는 것.
- 유튜브는 원하는 수준의 모듈성을 새로운 아키텍처에 녹였고, MSA로의 전환을 통해 해결하였다.

---
### 24.3 변경을 격리해 평가하자: 기능 플래그로 보호하기
> 지속적인 릴리스를 안정적으로 수행하는 핵심은 엔지니얻르이 '모든' 변경에 플래그 가드를 넣도록 하는 것이다!
>
> 플래그 가드란 플래그를 이용하여 제품의 코드를 기능단위로 제어 하는 기법

- 빌드 도구는 기능별 플래그를 확인하여 비활성화된 기능은 해당 빌드에서 제외
- 바이너리에 레거시와 새로운 기능을 실행하는 코드를 모두 넣기도 한다. 다만, 새로운 코드 실행 길목을 플래그가 막아서게 하는 것!
  - 현재 관리자 사이트의 상태와 유사

---
### 24.4 기민해지기 위한 분투: 릴리스 열차 갖추기
> 구글이 `검색` 기능을 배포할 때 겪었던 릴리스의 딜레이 문제! 과정을 간소화를 어떻게 할 것인가?

#### 24.4.1 완벽한 바이너리는 없다.
> 이전 모든 챕터에서와 마찬가지로 완벽할 수 없음을 인정해야 한다.

- 핵심 성과 지표(KPI)와 명확한 문턱값을 활용하면 비록 완벽하지는 않더라도 기능을 출시할 수 있음
- 구글의 필리핀 방언으로 인한 릴리스 문제
  - '매우 작은 필리핀 섬 하나에만 해당하는 이 버그를 수정하기 위해 주요 릴리스를 지연해야 할까요?'

#### 24.4.2 릴리스 시한을 지켜라.
> '릴리스 열차 시간에 늦으면 기다리지 않고 출발할 것이다'

- 릴리스가 다가오면 어느 시점부터 완고한 자세로 개발자와 그들이 들고 온 새로운 기능을 외면해야 한다.
- 하지만 드물게 예외는 존재하며, 어느 정도의 예외는 허용해야 개발자들의 워라벨을 개선해줄 수 있다.

---
### 24.5 품질과 사용자에 집중: 사용할 기능만 배포하자
> 대다수 소프트웨어는 사라지기 전에 팽창(bloat)이라는 불행한 부작용을 경험하는데, 지나치게 팽창하여 제품팀과 사용자에게까지 문제를 일으킬 수 있다.

- 제품이 비대해지는 것을 방지하기 위해 구글은 제품의 효율을 지속적으로 개선하는 전담 팀을 꾸리기도 한다.
- 제품을 얼마나 자주 업데이트하느냐에 따라 장단점이 있는데, 중요한 것은 '의식적으로 선택' 해야 한다는 것이다.
  - 네이티브 앱의 경우 빈번한 배포는 사용자들이 싫어할 수 있다.
  - 지속적 배포 프로세스가 부드럽게 잘 운영된다면 동작하는 릴리스를 얼마나 자주 '만들지'와 사용자가 얼마나 자주 '받을지'를 구분해 관리할 수 있다.
- 코드 모듈화를 통해서도 동적으로 설정 가능한 배포 전략을 구사할 수 있다.

> 이러한 프로세스를 갖추려면 비용을 선제적으로 투입해야 한다.

---
### 24.6 원점 회귀: 데이터에 기초해 더 일찍 결정하자
> '클라이언트 시장의 다양성은 문제가 아니라 현실이다'

- 종합적인 테스트가 현실적으로 불가능하다면 대표적인 테스트만을 목표로 한다.
- 사용자 기반을 조금씩 늘려가며 배포하면 문제를 빠르게 수정할 수 있다.
- 자동화된 A/B 릴리스를 이용하면 릴리스 품질 판별에 도움이 되는 통계적으로 중요한 결과를 얻을 수 있다. 피곤하게 대시보드만 쳐다보며 결정할 일이 없어진다.


- 구글은 테스트 트랙과 단계적 출시를 활용하여 어떤 문제가 일어나는지를 주의 깊게 모니터링함
  - 배포 A/B 테스트를 통해서 두 사용자 그룹의 지표를 비교하여 새로운 버전이 실제로 개선되었는지를 확인함.

---
### 24.7 팀 문화 바꾸기: 배포 규율 세우기
> '늘 배포하라(Always Be Deploying)'

- 규모가 늘면서 커진 복잡성은 보통 릴리스 주기가 길어지는 형태로 나타나게 된다.
- 하지만 릴리스 열차가 자주 오면 이전의 '좋은' 상태와의 차이가 적어서 문제가 생겨도 살펴봐야 할 범위가 좁혀진다.

> 각각의 기능은 매우 소중하지만 릴리스를 멈춰 세울 정도로 중요한 기능은 거의 없다. 
> 빠른 주기를 통해 릴리스 열차를 놓쳤더라도 다음 열차를 탑승 할 수 있는 시간을 줄이도록 하자

