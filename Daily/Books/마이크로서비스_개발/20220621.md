## Chapter 5. 마이크로서비스 설계
> 모듈화! 는 늘 중요했고 마이크로서비스 역시 어떻게 기능적으로 응집성 있는 마이크로서비스를 도출하고, 타 서비스
> 간의 의존도는 낮출 것인가를 관심사로 한다.

### 마이크로서비스를 도출하는 방법
#### 비즈니스 능력에 근거한 도출
> 비즈니스 능력(capability)에 따라 마이크로 서비스를 식별할 수 있다. - 크리스 리처드슨 <<마이크로서비스 패턴>>

여기서 비즈니스 능력이란, 비즈니스 가치를 생산하기 위해 하는 일이며, 곧 조직이 하는 일이라고 말한다.
즉, 조직과 같이 각 비즈니스 부서가 가진 역할, 처리 능력을 체계적으로 분해하여(업무 기능 분해) 업무 흐름에 따라 업무를
최상위에서 하위까지 분리하고 일들을 체계적으로 정렬할 수 있는데, 이를 `마이크로서비스`에 반영하는 것을 의미한다.

- 장점
  - 전체적인 비즈니스를 이해하기 쉽다.
- 단점
  - 서비스 간의 관계를 파악하거나 서비스의 구체 기능과 연관된 서비스가 관리할 독립적인 데이터를 식별하기 어렵다.

#### DDD의 바운디드 컨텍스트 기반 도출
마이크로서비스는 각 저장소를 독립적으로 보유하고, 각 데이터는 다른 서비스에서 직접 참조해서는 안되는 특징을 가진다.
다시 말해, 서비스가 소유권을 가진 데이터를 독립적으로 식별하는 것이 중요하다. 하지만, 앞선 비즈니스 능력에 근거한 설계는
하나의 통합 데이터가 여러 기능에서 사용되도록 모델링이 되기 때문에, 적합하지 않을 수 있다.

DDD에서는 데이터를 기능과 분리해서 식별하지 않고, 문제 영역인 하위 도메인마다 별도의 도메인 모델로 정의한다. 이처럼
분리된 도메인 모델에 의해 다른 컨텍스트와 구별되는 경계를 `바운디드 컨텍스트`라고 부른다.

### DDD의 전략적 설계
#### 도메인과 서브 도메인
DDD는 하나의 큰 도메인을 전략적으로 중요한 것들을 찾아 중요도에 따라 도메인을 나누고, 각 도메인을 각각 하나씩 해결하는 
방법을 기본으로 한다! 하나로 엮인 복잡한 비즈니스 도메인을 논리적으로 구분되는 여러 개의 하위 영역으로 분리해야 한다는 뜻이다.
이 때, 분리된 하위 도메인을 서브 도메인이라고 한다.

1. 핵심 서브도메인
    다른 경쟁자와 차별화를 만들 비즈니스 영역으로, 가장 높은 우선순위를 갖는 영역
2. 지원 서브도메인
    비즈니스에 필수적이지만 핵심은 아닌 부분이지만 핵심 서브도메인을 성공시키기 위해 필수적인 영역
3. 일반 서브도메인
    비즈니스적으로 특화된 부분은 아니지만, 전체 비즈니스 솔루션에는 필요한 부분

전략적 설계를 수행하기 위해 반드시 알아야 할 두가지!

1. 바운디드 컨텍스트: 도메인의 주요개념 정의 및 도메인 간의 경계를 식별
2. 유비쿼터스 언어: 도메인의 모든 구성원이 공통으로 사용

#### 유비쿼터스 언어와 도메인 모델, 바운디드 컨텍스트
> **유비쿼터스 언어**란 특정 도메인에서 해당 도메인에서의 의도를 명확히 반영하고 도메인의 핵심 개념을 잘 전달할 수 있는 
> 언어를 유비쿼터스 언어라고 한다.

특정 프로젝트나 전체 시스템에서 하향식으로 규정됐던 개념에서, 그보다 작은 단위의 세부 도메인에 특정 업무와 관련된 사람들
간에 자율적으로 정의되고 통용되는 개념을 의미한다.

예를 들어, 결제와 배송에서의 고객이 의미하는 바가 서로 다른데(계좌 정보를 가진 결제자 / 구매한 상품을 배송받는 자) 이와 같이
각 도메인 모델과 다른 도메인 모델간의 경계가 보이기 시작한다. 이를 바운디드 컨텍스트라고 한다.

#### 컨텍스트 매핑
> 바운디드 컨텍스트는 내부적으로는 응집성이 높아야 하짐나, 다른 컨텍스트와는 의존관계가 낮아야 한다. 하지만 두 컨텍스트 
> 사이에 연관성이 없는 것은 아니다.

1. 공유 커널(Shared Kernel)
    공통적인 모듈을 공유하는 관계로, 수정 시에 여러 컨텍스트에 영향을 미칠 수 있으므로 한 팀에서 관리
2. 소비자와 공급자(Customer-Supplier)
    공급하는 컨텍스튼 상류(upstream)으로, 소비하는 컨텍스트는 하류(downstream)으로 표시하여, 데이터의 흐름을 정의
3. 준수자(Confirmist)
    상류 팀이 하류 팀의 요구를 지원하지 않거나 못하는 경우 사용
4. 충돌 방지 계층(ACL; Anti-Corruption Layer)
    하류 팀이 상류 팀의 모델에 영향을 받을 때 하류 팀의 고유 모델을 지키기 위한 번역 계층을 만드는 것.
    즉, 상류 모델의 변경 없이 하위 모델과 통합하기 위해 데이터를 변환하는 메커니즘을 구현
5. 공개 호스트 서비스(OHS; Open Host Service)
    바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의. 다른 컨텍스트에서 사용할 수 있는 공유된 API
6. 발행된 언어(PL; Published Language)
    하류의 컨텍스트가 상류 컨텍스트가 제공하는 기능을 사용하게 하기 위한 간단한 사용과 번역을 가능케 하는 문서화된
    정보 교환 언어.

### 이벤트 스토밍을 통한 마이크로서비스 도출
> 이벤트 스토밍이란 이벤트 중심으로 이해관계자들이 모여 브레인 스토밍하는 워크숍을 의미

- 액터: 사용자 또는 역할자
- 커맨드: 시스템 조작
- 동작: 도메인 이벤트

넓은 보드에 스티커와 마커 테이프등을 이용하여 이벤트 스토밍을 진행한다!
이 때 각 스티커에는 대표적인 의미를 부여하는 것이 좋다.

| 유형 | 크기/색깔 | 설명 |
|:---:|:---------:|:---:|
| 도메인 이벤트 | 오렌지색 | 발생한 사건, 과거 시제 동사로 표현 |
| 커맨드 | 파란색 | 도메인 이벤트를 트리거하는 명령 |
| 외부 시스템 | 핑크색 | 도메인 이벤트가 호출하거나 관계가 있는 레거시 또는 외부 시스템 | 
| 액터 | 작은 노란색 | 개인 또는 조직의 역할 |
| 애그리거트 | 노란색 | 도메인 이벤트와 커맨드가 처리하는 데이터(상태가 변경되는 데이터) |
| 정책 | 라일락 | 이벤트 조건에 따라 진행되는 결정 (When [이벤트] Then [커맨드]) |
| 읽기 모델 | 초록색 | 도메인 이벤트 액터에게 제공되는 데이터 |
| 사용자 인터페이스 | 흰색 | 스케치 형태의 화면 레이아웃 |
| 핫스팟 | 자주색 | 의문, 질문, 미결정 사항 |

#### 도메인 이벤트 찾기 
> 시간 흐름에 따른 시스템의 동작을 의미하는 `도메인 이벤트`를 도출한다!

이벤트는 왼쪽에서 오른쪽으로 시간 흐름순으로 붙이되 연쇄적으로 발생하는 경우 바로 옆에 붙인다.
같은 시점에 비즈니스 조건에 따라 대체적으로 발생할 수 있는 이벤트는 세로로 아래쪽에 붙인다.

**중요한 것은 화면을 연상하지 말고 비즈니스가 흘러감에 따라 구성 요소들의 상태가 어떻게 변경되는지 생각한다**

#### 외부 시스템 도출
> 레거시 시스템이나 외부 시스템과의 연계를 통해 업무의 흐름이 진행될 때는 이벤트의 오른쪽 상단에 외부 시스템을 표시한다.

#### 커맨드 도출
> 찾아낸 도메인 이벤트를 동작하게 하는 커맨드(Command)를 찾는 과정!

#### 핫스폿 도출
> 이벤트 스토밍 워크샵 도중에 정의할 수 없는 문제들에 대해서는 핫스폿을 작성하여 붙인다.

#### 액터 도출
> 커맨드를 실행하는 액터(Actor)를 도출하는데, 이는 사용자/조직/역할자를 의미함

**보편적으로 사용되는 회원이나 관리자로 정의해서는 안됨! 특정 비즈니스를 실제로 수행하는 판매자, 구매자, 상품 관리자와 
같이 명확한 역할자를 도출해야함**

#### 애그리거트 정의
> DDD의 전술적 설계의 구성요소로서 가장 작은 도메인 모델의 모듈 단위인 `애그리거트`를 커맨드와 도메인 이벤트 사이의
> 상단에 붙인다

#### 바운디드 컨텍스트 그리기
> 이름이 같거나 유사한 애그리거트를 완전히 다른 애그리거트와 구분해서 경계를 그린다. 경계를 그리고 각 바운디드 컨텍스트
> 에 이름을 붙인다.

#### 정책을 도출하면서 연관관계 생각하기
> [도메인 이벤트]할 때는 항상 [커맨드]한다. 와 같은 정책을 도출하여 다른 바운디드 컨텍스트와의 관계를 식별한다.

#### 컨텍스트 매핑
> 식별된 바운디드 컨텍스트 간의 관계를 컨텍스트 맵으로 표현한다. 단! 호출 관계를 고려하여 방향을 설정해야 한다.
> 컨텍스트 간에 항상 일관된 데이터가 필요한 관계는 **동기 호출**로, 결과적 일관성으로 충분히 처리 가능한 관계는
> **비동기 방식 호출**로 표현!!






---
**느낀점**
1. 소프트웨어 공학 수업을 들으면서 접했던 UML에 대해서 다소 귀찮고, 번거로운 작업이라고 생각했으나 프로젝트의
   도입 및 시작 부에서는 필요할 수 있겠다.. 라고 생각한 적이 있었음. 하지만, 설계 단계에서의 용어와 개발 단계에서의
    용어가 달라 결국 단어 사전을 만드는 번거로운 작업을 했어야 하는데 DDD에서는 이를 보완할 수 있겠다는 생각이 듦
2. 

--- 
2022.06.22 스터디하면서 나눈 내용들
1. 오프닝 질문?
