---
start: 2024-08-25T14:00:00
end: 2024-09-01T18:00:00
location: 우아한테크살롱
---
# Part 1
> 광의의 DDD에 대해서 보편적인 개념을 알 수 있다.

### 1. DDD와 객체지향

- 객체지향
	- 비즈니스 로직을 구현함에 있어서 로직을 어디에 어떻게 배치할까에 대한 관심
- DDD
	- 훨씬 큰 범주의 문제를 다룸
	- 사용자에게 어떤 경험을 제공하기 위해 관련된 문제를 해결하는 것에 기반을 둔다.
	- **소프트웨어의 본질**
	- Pattern

> 도메인 주도 설계는 복잡한 도메인을 다뤄야 하는 소프트웨어 프로젝트에 박차를 가하는 것을 목표로 삼는 사고방식이자 우선순위의 모음이다.


### 2.  동작하는 도메인 모델 만들기

> 도메인 : 사용자가 프로그램을 사용하는 주제 영역
- 문제해결을 위해서 잡는 범위가 가장 러프한 범위의 도메인이라고 볼 수 있음

> 모델  : 당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 중요하지 않은 세부사항은 생략하는 것
- 커뮤니케이션 불일치를 방지하기 위해 사전지식을 맞추는 작업
- 대상의 단순화

> 도메인 모델 : 주제 영역 안에서 당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 중요하지 않은 세부사항은 생략하는 것

- 동작하는 도메인 모델
	- 모델과 핵심 설계는 서로 영향을 주며 반복을 통해 구체화 되는 것
	- 코드가 바뀌면 모델, 설계 역시 변경되어야 함
	- 즉, 도메인 모델 그 자체가 코드다.
- 지식 탐구(Crunching Knowledge)
	- 개발이 전부가 아니다.
	- 도메인 전문가 와의 활발한 논의가 필요함
- 유비쿼터스 언어(Ubiquitous Language)
	- 도메인 전문가와 개발자 사이의 커뮤니케이션 수단
	- 커뮤니케이션 많이 해!

### 3. 객체지향 설계에서 도메인 주도 설계로

> 업무 패러다임을 바꿨던 기술 : 웹, 모바일 부상
- 웹의 부상으로 분산 객체 기술이 유행
	- EJB 컨테이너
	- 객체 단위의 통신(Location transparency)
	- 단, EJB가 강요하는 인터페이스나 추상클래스 상속이 강제됨
		- 즉, 기술의 제약에 아키텍처 제한이 걸려버림(침투적인 아키텍처)
- 90 - 00년대 기술 관심사와 도메인 관심사가 혼재되어 있었음
	- 서로 다른 이유로 바뀌는 무언가들이 함께 뭉쳐져 있으면 유지보수에 어려움을 겪게됨
- POJO의 등장
- 2003년 DDD의 등장

- 분산 객체 기술의 문제점
	- **표현적(의미적) 차이**
		- 도메인 모델과 소프트웨어 내부에 표현된 도메인 개념 사이의 거리
		- 내가 생각하는 위치에 도메인 로직이 있어야 하는데 없네?
	- 침투적인 기술로 인한 커뮤니케이션 복잡성
		- 기술적인 커뮤니케이션으로 변경되어 버림
- 해결방법
	- 모델 주도 설계(model-driven design)

### 4. 모델 주도 설계의 빌딩 블록

> 도메인 주도 설계의 전제 조건은 도메인 구현을 격리하는 것
- 아키텍처는 상관없어, 도메인 로직만 격리하면 돼

- 모델 주도 설계의 빌딩 블록
	- 구현 가능한 도메인 모델을 구성하는 요소들의 목록
	- 도메인을 표현하기 위한 빌딩 블록(이렇게 나눠야지!)
		- Entity, Value Object, Association, Service, Module
	- 생명주기를 관리하기 위한 빌딩 블록(이렇게 관리해야지!)
		- Aggregate, Repository, Factory
- 불변식(Invariant)
- 애그리거트(Aggregate)
	- 불변식을 만족시키는 객체 그룹 단위로 처리
		- -> 불변식, 도메인
	- 트랜잭션 단위
	- Aggregate 단위로 트랜잭션 경계를 구성해야 함
	- Aggregate 단위로 Repository 추가
- 결과적 일관성(Eventual Consistency)
- Patterns of enterprise application architecture - martin fowler
	- 트랜잭션 스크립트
	- 도메인 모델

### 5. 애자일과 도메인 주도 설계
> Embrace change
- 반복적이고 점증적인 프로세스
- 반복을 통해 명확해지는 요구사항
- 짧은 주기의 반복 단위로 변경사항 반영

- 진화적인 설계의 핵심은 리팩토링(refactoring)

**애자일과 도메인 주도 설계**
- 개발은 반복주기를 통해 진행되어야 한다.
- 개발자와 도메인 전문가는 밀접한 관계를 가져야 한다.

> 완벽한 도메인을 만들기 위한 노력보다는, 지금 필요한 것 위주로 만들 것
- 도메인 전문가와 개발자가 함께 도메인에 대한 통찰을 반영해 도메인 모델을 리팩터링

### 6. 전략적 설계
> 개발과 정치가 만나는 곳

- **도메인 모델을 시스템에서 하나만 만들어야 돼!**
	- That's bull sxxt
	- Ownership을 가지고 작업할 수 있게 도메인을 나누고 우선순위를 정해야 함
- 응집도가 낮은 코드
	- Conflict이 나고 있어! -> 응집도가 낮은 코드
	- 단일 책임 원칙
	- 현실적으로 단계적으로 정리하면서 작업을 할 수가 없음(사업이 잘된다면 더더욱)

- 단일 도메일 모델
	- 기능 추가와 코드 수정 시 충돌
	- 통제하기 어려운 사이드 이펙트
	- 협업 오버헤드
	- 릴리즈 일정 협의
	- **의미적 충돌로 인한 언어의 모호함**
		- 불변식을 위반하는 데이터가 발생하는 경우
		
- 어떤 경우에는 결합도가 높은 것보다 코드 중복이 발생하는 경우가 나을 수도 있음
	- MSA 작업할 때, 데이터 중복을 우선 허용하고 가기도 함
		- DMS
	- 의도된 중복은 나쁘지 않다(Entity -> DTO 매핑)

- 사용되는 컨텍스트에 따라 모델을 분리(**Bounded Context**)
	- 같은 바운디드 컨텍스트 안에서는 도메인 모델의 통합성 유지
	- 서로 다른 바운디드 컨텍스트 사이에서는 통합성에 신경 쓰지 않음
	- Vertical Slice로 잘라버림
	- DDD의 bounded-context는 논리적인 분리를 의미함
	- 팀 단위로 관리
- 컨텍스트 맵(Context-map)
	- 컨텍스트 사이의 관계와 모델 변환 방식 정의

- **전략적 디스틸레이션**
	- 우선순위를 정해라!
	- 시스템에서 가장 가치를 더하고 특별한 측면을 부각시켜야 해!
	- **코어 도메인**(Core domain)
		- 사업의 성공을 결정하는 핵심적인 서브도메인
		- 코어 도메인을 식별해서 강조하고 최고의 실력자를 배정해라
	- 제네릭 서브도메인(Generic Subdomain)
		- 비즈니스에 경쟁우위를 제공하지 않고 타사의 여러 애플리케이션에 공통으로 존재하는 서브도메인은?
		- 기성 소프트웨어 구입, 주니어 개발자 배정
	- 지원 서브도메인(Supproting subdomain)
		- 경쟁 우위를 제공하진 않지만 비즈니스의 일부로 코어 도메인을 지원하는 도메인
		- 외주로 해결, 개발자의 성장을 위한 기회

### 7. 도메인 주도 설계 그 후
> 전술적 패턴 - Part 2
> 전략적 패턴 - Part 4

- Bounded Context -> 솔루션 공간(Solution Space)
	- 시스템으로 도메인을 가져갔을 때, 바운디드 컨텍스트
- SubDomain -> 문제 공간(Problem Space)
	- 문제의 이름으로 나누면 도메인 영역

-> 도메인간의 트랜잭션 얘기에서 도메인 이벤트가 나오기 시작함
-> Domain-Driven Design Reference

- 이벤트 소싱(Event Sourcing)
	- 발행된 이벤트들로 도메인을 다시 재구축할 수 있는 것이 Event Sourcing

- CQRS(Command Query Responsibility Segregation)
	- 조회용 도메인 모델과 수정용 도메인 모델을 분리해
	- 원래의 CQRS는 물리 DB를 나누는 것까지는 아니었음
- MSA 아키텍처의 유행
	- EJB의 실패로 MSA
- 헥사고날 아키텍처의 재조명(Hexagonal Architecture) - 2005
	- 데이터베이스가 사용 불가능하더라도 작업이 가능하고, 사용자의 개입 없이도 애플리케이션을 연결할 수 있도록 UI나 DB 없어도 작동할 수 있는 애플리케이션 구축
	- 각기 다른 요청에 대응할 수 있게 하고 싶어서
	- 각기 다른 서비스 요청이 필요없으면 할 필요 없...음.....
- DDD, MSA, Hexagonal은 독립적임

- Patterns, Principles, and Practices of Domain-Driven Design - scott millet

---
# Part 2

> 어떤 단계에서 DDD에 대한 고민과 도입을 하는 것이 좋을지 고민해볼 필요가 있음
> 어떤 것이든 그렇겠지만 잘못 적용했을 때 좋을 것이 없기 때문

## 1. 모델 주도 설계
- 도메인 모델 = 코드
	- 생각하는 관점을 그대로 코드에 녹이기 위해 밸런스를 잡는 과정들(구현부 관점)

 - 요구사항에 적합한 모습으로 도메인을 어떻게 모델링할 것인가?
 - 도메인을 반영한 코드를 어떻게 개발할 것인가?

- 빌딩블록의 목적
	- 구현에 대한 가이드를 제공해서 복잡도를 낮추는 것
	- **도메인의 개념을 코드로 옮기기 위한 직관적인 가이드**

> 궁극적인 목표 : 복잡성 낮추기

- 불변식 도출의 기반은 **요구사항**

## 2. DDD에서의 기능 구현
- 기능 요구사항과 불변식을 애그리거트로 구현
- 조건, 특정 상태를 만듦에 있어 반드시 지켜져야할 제약조건이 바로 불변식

## 3. Entity, Value Object
- Entity
	- 식별자로 구분 가능함
	- 수많은 객체는 본질적으로 해당 객체의 속성이 아닌 연속성과 식별성이 이어지는지를 기준으로 정의된다.
	- **식별자 동일성**
- Value Object
	- 식별성이 없는 객체, 사물의 어떤 특성을 묘사
	- **속성 동등성**


> 연속성
> 형태를 시스템 연동을 위해 다양한 형태(DB, Memory, Queue)로 이동하더라도, 원래의 Entity를 식별할 수 있음을 의미(형태와 상태가 바뀌더라도 엔티티 대상을 추적 가능)

- Entity의 단점
	- 상태가 다를 경우에도 동일한 객체로 식별하는데 따르는 복잡성
- 값 객체와 복잡성 낮추기
	- 어떤 요소의 속성에만 관심이 있다면 Value Object로 분류
	- 값만 같으면 동일하다고 판단

- 값 객체 != DTO
	- `Data는 불안정한 상태로 만들고 Validation을 하지만, Entity와 Value Object는 만들어지는 시점에서 불변성을 만족해야 함`

- 주크, spring data JDBC

> Value Object가 불변적이라면 변경관리는 단순해진다.

> 개념에 필수적인 행위만 추가하고 그 행위에 필요한 속성만 추가한다. 그 밖의 객체는 행위의 속성을 검토해서 가장 중심이 되는 Entity와 연관관계에 있는 다른 객체로 옮긴다. 이들 중 일부는 ENTITY가 될 것이다. 또 어떤 것은 Value Object가 될 것이다.


## 4. 연관관계와 애그리거트
> Entity와 Value Object를 이해하기 위해서는 Aggregate 개념과 활용 방법을 이해하는 것이 중요

- 책임 주도 설계(Responsibility-Driven Design) <- 기능 요구사항
- 계약에 의한 설계(Design By Contract) <- 불변식

> 불변식(Invariant) : 언제나 일관되게 유지돼야 하는 비즈니스 규칙, 불변식은 트랜잭션 일관성(Transactional Consistency)과 관련

>개발은 경계(의존성)다.

애그리거트를 하는 이유는 코드의 유지보수를 잘하기 위함이며, 이를 위해 경계를 설정하는 것이다.
- 모델 내의 참조에 대한 캡슐화를 추상화시킬 필요가 있다.
- AGGREGATE는 우리가 데이터 변경의 단위로 다루는 연관 객체의 클러스터를 의미
- 특정한 객체를 통해서만 내부의 객체에 접근할 수 있게 처리

> 의존성 설계가 중요하다
- 불변식을 기준으로 애그리게이트 경계 정의
- 트랜잭션 단위로 저장/조회 처리

## 5. Repository
> 애그리거트 단위로 리포지토리(Repository)를 추가한다.

- Repository의 원취지는 메모리상에 해당 타입의 객체로 이루어진 컬렉션이 있다는 착각을 불러 일으키는 객체를 만들게 하는 것

- Transactional Consistency
	- 항상 불변성을 만들어주는 상태
- Eventual Consistency
	- 불변성이 만들어지지 않아도 되는 상태


## 6. 연관관계
> 모델 내의 모든 탐색 가능한 연관관계에 대해, 그것과 동일한 특성을 지닌 매커니즘이 소프트웨어에도 존재한다.


- 양방향 보다는 단방향 설계가 유리함
- 다중성 줄이기
	- One-To-Many -> Many-To-One
- 한정자를 이용해서 다중성 줄이기
	- One-To-Many -> One-To-One
- 불필요한 연관관계 제거하기

- **Repository를 연관관계를 해결하기 위한 하나의 수단으로써 생각해보자**
	- Aggregate 외부 : 복잡성 감소를 위해 ID를 이용해 참조하게 설계
	- Aggregate 내부 : 객체 참조를 통해 탐색

## 7. 애그리게이트 경계 정하기
- 루트가 애그리게이트 전체의 불변식을 보장해야 함

- 침투적인 설계는 단위 테스트가 불가능할 경우


## 8. 팩토리와 서비스
- 설계가 매우 명확하고 실용적이더라도 개념적으로 어떠한 객체에도 속하지 않는 연산이 포함될때가 있음

- 서비스
	- application service
		- 흔히 알고 있는 @Service
		- 컴퓨터 환경이 들어간 것
	- Domain service
		- 도메인의 행위가 필요한 경우
		- 컴퓨터 환경을 제외했을 때 비즈니스 로직을 파악할 수 있는 레이어
		- 게층간의 조율이 필요할 때
	- repository service



---
# Q & A

# P1
### 내가 궁금했던 것

1. DIP를 통한 인프라스트럭처 연결을 할 때, 복수의 인프라스트럭처가 필요하다면 어떤 식으로 구성하는 것이 가장 좋을지?
	1. 
2. 00년대 초반부터 흐름이 있었으나 왜 지금에 와서야 DDD가 더 각광을 받기 시작한걸까?
	1. MSA가 각광받기 시작하면서 뜨기 시작한겨
 2. 같은 도메인이라 하더라도, 사용자 권한에 따른 처리가 달라져야 하는데 도메인 복잡도가 올라가더라도 단일 도메인을 사용하는지, 별도의 어그리거트를 생성하는지

### 다른 분들이 궁금했던 것

1. UI 입장에서의 DDD는 어떻게?
	1. 사실 DDD는 `불변성`에 키워드를 맞춰 본다면 CUD에 해당하는 내용. 즉, 조회에 대한 내용은 DDD와 살짝 동떨어져 있음
2. Bounded Context 도메인의 명명 규칙 어떻게 하는게 좋을까
	1. 도메인과 바운디드 컨텍스트가 1:1이 되는게 가장 좋음
	2. 가장 많이 쓰는 명칭으로 사용하는 것이 좋음

# P2
## 내가 궁금했던 것

1. 관리자사이트와 같이 Admin 용 도메인 분리의 효율적인 방법이 궁금
3. 애그리게이트를 통한 수정을 진행할 때, 일부 Entity는 수정, 일부 Entity는 추가되어야 한다면 어떻게 구성하는 것이 좋을지?
	1. 내부 Entity에 대한 등록 처리를 위한 Repository를 생성안해도 되는건지
	2. 스냅샷 로그를 위해 변경된 내부 Entity에 대한 로그를 적재해야 하는 상황이라면?
4. `Rule을 지키는 쿼리들을 내보내면 될 건데 왜 Stream으로 구현하는데?`에 대해서 어떤 적합한 답변이 좋을지.. 
5. 순환참조가 발생하는 Entity의 Aggregate 경계는 어떻게 될지
	1. Rule 이 중요
	2. 각 Entity의 행위가 어떤 차이를 가지고 있는지, Rule 베이스로 분리 여부를 고민해볼 것
	3. 대부분이 동일한 행위와 제약조건을 같는다면 동일한 Entity를 사용하는게 좋음

> Entity를 Cache에 바로 밀어 넣지 않음

## 다른 분들이 궁금했던 것
