---
start: 2024-08-25T14:00:00
end: 2024-09-01T18:00:00
location: 우아한테크살롱
---
# Part 1
> 광의의 DDD에 대해서 보편적인 개념을 알 수 있다.

### 1. DDD와 객체지향

- 객체지향
	- 비즈니스 로직을 구현함에 있어서 로직을 어디에 어떻게 배치할까에 대한 관심
- DDD
	- 훨씬 큰 범주의 문제를 다룸
	- 사용자에게 어떤 경험을 제공하기 위해 관련된 문제를 해결하는 것에 기반을 둔다.
	- **소프트웨어의 본질**
	- Pattern

> 도메인 주도 설계는 복잡한 도메인을 다뤄야 하는 소프트웨어 프로젝트에 박차를 가하는 것을 목표로 삼는 사고방식이자 우선순위의 모음이다.


### 2.  동작하는 도메인 모델 만들기

> 도메인 : 사용자가 프로그램을 사용하는 주제 영역
- 문제해결을 위해서 잡는 범위가 가장 러프한 범위의 도메인이라고 볼 수 있음

> 모델  : 당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 중요하지 않은 세부사항은 생략하는 것
- 커뮤니케이션 불일치를 방지하기 위해 사전지식을 맞추는 작업
- 대상의 단순화

> 도메인 모델 : 주제 영역 안에서 당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 중요하지 않은 세부사항은 생략하는 것

- 동작하는 도메인 모델
	- 모델과 핵심 설계는 서로 영향을 주며 반복을 통해 구체화 되는 것
	- 코드가 바뀌면 모델, 설계 역시 변경되어야 함
	- 즉, 도메인 모델 그 자체가 코드다.
- 지식 탐구(Crunching Knowledge)
	- 개발이 전부가 아니다.
	- 도메인 전문가 와의 활발한 논의가 필요함
- 유비쿼터스 언어(Ubiquitous Language)
	- 도메인 전문가와 개발자 사이의 커뮤니케이션 수단
	- 커뮤니케이션 많이 해!

### 3. 객체지향 설계에서 도메인 주도 설계로

> 업무 패러다임을 바꿨던 기술 : 웹, 모바일 부상
- 웹의 부상으로 분산 객체 기술이 유행
	- EJB 컨테이너
	- 객체 단위의 통신(Location transparency)
	- 단, EJB가 강요하는 인터페이스나 추상클래스 상속이 강제됨
		- 즉, 기술의 제약에 아키텍처 제한이 걸려버림(침투적인 아키텍처)
- 90 - 00년대 기술 관심사와 도메인 관심사가 혼재되어 있었음
	- 서로 다른 이유로 바뀌는 무언가들이 함께 뭉쳐져 있으면 유지보수에 어려움을 겪게됨
- POJO의 등장
- 2003년 DDD의 등장

- 분산 객체 기술의 문제점
	- **표현적(의미적) 차이**
		- 도메인 모델과 소프트웨어 내부에 표현된 도메인 개념 사이의 거리
		- 내가 생각하는 위치에 도메인 로직이 있어야 하는데 없네?
	- 침투적인 기술로 인한 커뮤니케이션 복잡성
		- 기술적인 커뮤니케이션으로 변경되어 버림
- 해결방법
	- 모델 주도 설계(model-driven design)

### 4. 모델 주도 설계의 빌딩 블록

> 도메인 주도 설계의 전제 조건은 도메인 구현을 격리하는 것
- 아키텍처는 상관없어, 도메인 로직만 격리하면 돼

- 모델 주도 설계의 빌딩 블록
	- 구현 가능한 도메인 모델을 구성하는 요소들의 목록
	- 도메인을 표현하기 위한 빌딩 블록(이렇게 나눠야지!)
		- Entity, Value Object, Association, Service, Module
	- 생명주기를 관리하기 위한 빌딩 블록(이렇게 관리해야지!)
		- Aggregate, Repository, Factory
- 불변식(Invariant)
- 애그리거트(Aggregate)
	- 불변식을 만족시키는 객체 그룹 단위로 처리
		- -> 불변식, 도메인
	- 트랜잭션 단위
	- Aggregate 단위로 트랜잭션 경계를 구성해야 함
	- Aggregate 단위로 Repository 추가
- 결과적 일관성(Eventual Consistency)
- Patterns of enterprise application architecture - martin fowler
	- 트랜잭션 스크립트
	- 도메인 모델

### 5. 애자일과 도메인 주도 설계
> Embrace change
- 반복적이고 점증적인 프로세스
- 반복을 통해 명확해지는 요구사항
- 짧은 주기의 반복 단위로 변경사항 반영

- 진화적인 설계의 핵심은 리팩토링(refactoring)

**애자일과 도메인 주도 설계**
- 개발은 반복주기를 통해 진행되어야 한다.
- 개발자와 도메인 전문가는 밀접한 관계를 가져야 한다.

> 완벽한 도메인을 만들기 위한 노력보다는, 지금 필요한 것 위주로 만들 것
- 도메인 전문가와 개발자가 함께 도메인에 대한 통찰을 반영해 도메인 모델을 리팩터링

### 6. 전략적 설계
> 개발과 정치가 만나는 곳

- **도메인 모델을 시스템에서 하나만 만들어야 돼!**
	- That's bull sxxt
	- Ownership을 가지고 작업할 수 있게 도메인을 나누고 우선순위를 정해야 함
- 응집도가 낮은 코드
	- Conflict이 나고 있어! -> 응집도가 낮은 코드
	- 단일 책임 원칙
	- 현실적으로 단계적으로 정리하면서 작업을 할 수가 없음(사업이 잘된다면 더더욱)

- 단일 도메일 모델
	- 기능 추가와 코드 수정 시 충돌
	- 통제하기 어려운 사이드 이펙트
	- 협업 오버헤드
	- 릴리즈 일정 협의
	- **의미적 충돌로 인한 언어의 모호함**
		- 불변식을 위반하는 데이터가 발생하는 경우
		
- 어떤 경우에는 결합도가 높은 것보다 코드 중복이 발생하는 경우가 나을 수도 있음
	- MSA 작업할 때, 데이터 중복을 우선 허용하고 가기도 함
		- DMS
	- 의도된 중복은 나쁘지 않다(Entity -> DTO 매핑)

- 사용되는 컨텍스트에 따라 모델을 분리(**Bounded Context**)
	- 같은 바운디드 컨텍스트 안에서는 도메인 모델의 통합성 유지
	- 서로 다른 바운디드 컨텍스트 사이에서는 통합성에 신경 쓰지 않음
	- Vertical Slice로 잘라버림
	- DDD의 bounded-context는 논리적인 분리를 의미함
	- 팀 단위로 관리
- 컨텍스트 맵(Context-map)
	- 컨텍스트 사이의 관계와 모델 변환 방식 정의

- **전략적 디스틸레이션**
	- 우선순위를 정해라!
	- 시스템에서 가장 가치를 더하고 특별한 측면을 부각시켜야 해!
	- **코어 도메인**(Core domain)
		- 사업의 성공을 결정하는 핵심적인 서브도메인
		- 코어 도메인을 식별해서 강조하고 최고의 실력자를 배정해라
	- 제네릭 서브도메인(Generic Subdomain)
		- 비즈니스에 경쟁우위를 제공하지 않고 타사의 여러 애플리케이션에 공통으로 존재하는 서브도메인은?
		- 기성 소프트웨어 구입, 주니어 개발자 배정
	- 지원 서브도메인(Supproting subdomain)
		- 경쟁 우위를 제공하진 않지만 비즈니스의 일부로 코어 도메인을 지원하는 도메인
		- 외주로 해결, 개발자의 성장을 위한 기회

### 7. 도메인 주도 설계 그 후
> 전술적 패턴 - Part 2
> 전략적 패턴 - Part 4

- Bounded Context -> 솔루션 공간(Solution Space)
	- 시스템으로 도메인을 가져갔을 때, 바운디드 컨텍스트
- SubDomain -> 문제 공간(Problem Space)
	- 문제의 이름으로 나누면 도메인 영역

-> 도메인간의 트랜잭션 얘기에서 도메인 이벤트가 나오기 시작함
-> Domain-Driven Design Reference

- 이벤트 소싱(Event Sourcing)
	- 발행된 이벤트들로 도메인을 다시 재구축할 수 있는 것이 Event Sourcing

- CQRS(Command Query Responsibility Segregation)
	- 조회용 도메인 모델과 수정용 도메인 모델을 분리해
	- 원래의 CQRS는 물리 DB를 나누는 것까지는 아니었음
- MSA 아키텍처의 유행
	- EJB의 실패로 MSA
- 헥사고날 아키텍처의 재조명(Hexagonal Architecture) - 2005
	- 데이터베이스가 사용 불가능하더라도 작업이 가능하고, 사용자의 개입 없이도 애플리케이션을 연결할 수 있도록 UI나 DB 없어도 작동할 수 있는 애플리케이션 구축
	- 각기 다른 요청에 대응할 수 있게 하고 싶어서
	- 각기 다른 서비스 요청이 필요없으면 할 필요 없...음.....
- DDD, MSA, Hexagonal은 독립적임

- Patterns, Principles, and Practices of Domain-Driven Design - scott millet

---
# Part 2

> 어떤 단계에서 DDD에 대한 고민과 도입을 하는 것이 좋을지 고민해볼 필요가 있음
> 어떤 것이든 그렇겠지만 잘못 적용했을 때 좋을 것이 없기 때문

## 1. 모델 주도 설계
- 도메인 모델 = 코드
	- 생각하는 관점을 그대로 코드에 녹이기 위해 밸런스를 잡는 과정들(구현부 관점)

 - 요구사항에 적합한 모습으로 도메인을 어떻게 모델링할 것인가?
 - 도메인을 반영한 코드를 어떻게 개발할 것인가?

- 빌딩블록의 목적
	- 구현에 대한 가이드를 제공해서 복잡도를 낮추는 것
	- **도메인의 개념을 코드로 옮기기 위한 직관적인 가이드**

> 궁극적인 목표 : 복잡성 낮추기

- 불변식 도출의 기반은 **요구사항**

## 2. DDD에서의 기능 구현
- 기능 요구사항과 불변식을 애그리거트로 구현
- 조건, 특정 상태를 만듦에 있어 반드시 지켜져야할 제약조건이 바로 불변식

## 3. Entity, Value Object
- Entity
	- 식별자로 구분 가능함
	- 수많은 객체는 본질적으로 해당 객체의 속성이 아닌 연속성과 식별성이 이어지는지를 기준으로 정의된다.
	- **식별자 동일성**
- Value Object
	- 식별성이 없는 객체, 사물의 어떤 특성을 묘사
	- **속성 동등성**


> 연속성
> 형태를 시스템 연동을 위해 다양한 형태(DB, Memory, Queue)로 이동하더라도, 원래의 Entity를 식별할 수 있음을 의미(형태와 상태가 바뀌더라도 엔티티 대상을 추적 가능)

- Entity의 단점
	- 상태가 다를 경우에도 동일한 객체로 식별하는데 따르는 복잡성
- 값 객체와 복잡성 낮추기
	- 어떤 요소의 속성에만 관심이 있다면 Value Object로 분류
	- 값만 같으면 동일하다고 판단

- 값 객체 != DTO
	- `Data는 불안정한 상태로 만들고 Validation을 하지만, Entity와 Value Object는 만들어지는 시점에서 불변성을 만족해야 함`

- 주크, spring data JDBC

- 



---
# Q & A

# P1
### 내가 궁금했던 것

1. DIP를 통한 인프라스트럭처 연결을 할 때, 복수의 인프라스트럭처가 필요하다면 어떤 식으로 구성하는 것이 가장 좋을지?
	1. 
2. 00년대 초반부터 흐름이 있었으나 왜 지금에 와서야 DDD가 더 각광을 받기 시작한걸까?
	1. MSA가 각광받기 시작하면서 뜨기 시작한겨
 2. 같은 도메인이라 하더라도, 사용자 권한에 따른 처리가 달라져야 하는데 도메인 복잡도가 올라가더라도 단일 도메인을 사용하는지, 별도의 어그리거트를 생성하는지

### 다른 분들이 궁금했던 것

1. UI 입장에서의 DDD는 어떻게?
	1. 사실 DDD는 `불변성`에 키워드를 맞춰 본다면 CUD에 해당하는 내용. 즉, 조회에 대한 내용은 DDD와 살짝 동떨어져 있음
2. Bounded Context 도메인의 명명 규칙 어떻게 하는게 좋을까
	1. 도메인과 바운디드 컨텍스트가 1:1이 되는게 가장 좋음
	2. 가장 많이 쓰는 명칭으로 사용하는 것이 좋음

# P2
## 내가 궁금했던 것

1. 관리자사이트와 같이 Admin 용 도메인 분리의 효율적인 방법이 궁금
2. 상태 변경의 전파를 위해 이벤트 소싱이 거론되는 것으로 알고 있는데, 반드시 이벤트 중심이 좋을까? 어떤 경우에 DMS와 같은 솔루션을 사용하는 것이 좋을까?

## 다른 분들이 궁금했던 것
