> 2022년 10월 11일(화) 10:30 - Chapter 11

# Chapter 11. 테스트 개요
>  개발 주기에서 버그를 발견하는 시기가 늦어질수록 고치는 비용은 커진다. **자동테스트**는 버그가 몰래 숨어들어 고객을 놀라게하는 사태를 막아줄 수 있다.

- '버그 잡기'는 테스트를 수행하는 하나의 이유일 뿐.
- 대규모 재설계에서도 자동테스트는 실수를 빠르게 잡아줄 수 있다.

---
### 11.1 테스트를 작성하는 이유
> 자동 테스트: 테스트하려는 단 하나의 행위 / 특정한 입력 / 관측 가능한 출력 혹은 동작 / 통제된 조건

- 시스템에 특정 값을 입력하고, 출력 결과를 확인하여, 시스템이 기대한 대로 동작한 것인지를 판단하게 되는 것
- 간단한 테스트가 수백에서 수천 개 모이면(테스트 스위트 - test suite) 제품이 전체적으로 의도한 설계대로 잘 작동하는지 혹은
  언제 그렇지 못한 지를 이야기할 수 있음
- 테스트는 엔지니어에게 신뢰를 줄 때만 가치가 있다.

#### 11.1.1 구글 웹 서버 이야기
> 구글은 엔지니어들이 소프트웨어를 알아서 올바르게 만들어 줄 것이라 생각했고, GWS(Google Web Server)가 최악의 상황을 겪어봄

- GWS는 구글 검색 쿼리를 제공하는 웹 서버
- 제품 결함 해결은 프로그래머의 능력에만 의존해서는 안된다.

#### 11.1.2 오늘날의 개발 속도에 맞는 테스트
> 소프트웨어 시스템은 계속해서 더 커지고 복잡해지고 있으며, 추가되는 모든 기능을 사람이 조작하여 제품 품질을 확인하는 방식은 불가능하다.

- 답은 자동화!

#### 11.1.3 작성하고, 수행하고, 조치하라
>  가장 순수한 형태의 자동 테스트는 '테스트 작성', '테스트 수행', '실패한 테스트에 대한 조치'로 구성된다.

- 오늘날의 개발자들은 자신의 코드를 검사하는 자동 테스트를 작성하고 수행하는 데 능동적이고 핵심적인 역할을 수행한다.
- 분명한 것은 테스트를 작성하는 것과 **좋은 테스트**를 작성하는 것은 별개다.
- 테스트가 실패했을 때 빠르게 조치한다면, 제품과 테스트를 더 신뢰하며 오류를 빠르게 퇴치할 수 있다.

#### 11.1.4 테스트 코드가 주는 혜택
> 테스트를 작성하면 생산성과 속도가 높아진다고 생각하기 어려울 수 있다. 처음 기능 구현에 드는 시간만큼 혹은 그 이상을 테스트 작성에 써야 하기 때문

1. **디버깅 감소**
   1. 테스트를 한 번 작성해두면 프로젝트가 살아 있는 내내 값비싼 결함을 예방해주고 짜증 나는 디버깅에서 해방시켜준다.
2. **자신 있게 변경**
   1. 모든 소프트웨어는 변경된다.
   2. 자신감을 갖고 변경들을 리뷰하고 수용할 수 있다.
3. **더 나은 문서 자료**
   1. 한 번에 하나의 행위만 집중해 검증하는 명확한 테스트는 마치 실행 가능한 문서와 같다.
4. **더 단순한 리뷰**
   1. 정확성, 극단 상황, 오류 상황 등 다양한 측면에서 코드를 검사해주는 테스트가 준비되어있다면 리뷰어가 변경된 코드의 동작을 검증하는 시간이 줄어든다.
5. **사려 깊은 설계**
   1. 테스트하기 어려운 코드는 너무 많은 역할을 짊어지거나 의존성을 관리하기 어렵게 짜여졌을 가능성이 크다.
6. **고품질의 릴리즈를 빠르게**
   1. 건실한 테스트 스위트를 갖춘 팀은 새로운 버전을 릴리즈하며 불안해 하지 않는다.

---
### 11.2 테스트 스위트 설계하기
> 엔지니어들은 커다란 '시스템 규모'의 테스트를 작성하는 편을 선호하지만, 이러한 테스트는 작은 테스트와 비교하여 느리고 신뢰도가 낮고 디버깅도 어렵다.

> '작다'는 것은 그럼 무슨 의미인가?
> > **크기**: 테스트 케이스 하나를 실행하는데 필요한 자원(메모리, 프로세스, 시간...)
> 
> > **범위**: 검증하려는 특정한 코드 경로

#### 11.2.1 테스트 크기
> 작은 테스트는 프로세스 하나에서 동작하고, 중간 크기 테스트는 기기 하나에서, 큰 테스트는 자원을 원하는 만큼 사용해서 동작한다.

- 큰 테스트는 가장 복잡하고 검증하기 어려운 시나리오에만 제한적으로 활용

- **작은 테스트**
  - 가장 엄격한 제약
  - 단 하나의 프로세스에서 실행되어야 함
    - 테스트도 테스트 대상 코드와 같은 프로세스에서 실행되어야 함
    - 네트워크, 디스크에도 접근할 수 없어야 한다.
- **중간 크기 테스트**
  - 여러 프로세스와 스레드를 활용할 수 있으며, 로컬 호스트로의 네트워크 호출 같은 블로킹 호출도 이용할 수 있다.
  - 테스트 대상 코드를 더 현실적인 설정 하에서 검증할 수 있음
  - 유연해진 만큼 테스트는 느려지고 비결정적이 될 가능성은 크다.
- **큰 테스트**
  - 원격 클러스터에서 구동 중인 시스템을 테스트할 수 있음
- **테스트 크기와 무관한 공통 특성**
  - _모든 테스트는 밀폐(hermetic)되어야 한다_
  - 확인하려는 행위를 수행하는데 필요한 정보만을 포함해야 한다.
- **실제 상황에서의 테스트 크기**
  - 구글은 정의한 테스트 크기에 따라 실무에 적용할 수 있는 많은 도구를 만들어 낼 수 있었다.
  
#### 11.2.2 테스트 범위
> 주어진 테스트가 얼마나 많은 코드를 검증하는가.

- **좁은 범위 테스트(80%)**: 독립된 클래스나 메서드같이 코드베이스 중 작은 일부 로직을 검증하도록 설계
- **중간 범위 테스트(15%)**: 적은 수의 컴포넌트들 사이의 상호작용을 검증하도록 설계
- **넓은 범위 테스트(5%)**: 시스템의 서로 다른 부분들 사이의 상호작용, 혹은 여럿을 조합해 실행하면 나타나는 예기치 못한 동작 검증

- 단, '실행'되는 코드가 아니라 '검증'되는 코드의 양이 기준이다!

#### 11.2.3 비욘세 규칙
> '깨뜨려보고 싶은 모든 것을 테스트하라' / '니가 좋아했다면 테스트를 준비해뒀어야지'

- 카오스 엔지니어링을 활용하면 실제 프로덕션 네트워크에 영향을 주는 훨씬 더 큰 중단 사태도 시뮬레이션할 수 있음

#### 11.2.4 코드 커버리지
> 코드 커버리지란 어느 테스트가 기능 코드의 어느 라인을 실행하는지를 측정하는 수단

- 적은 수의 테스트만으로 상당량의 라인을 실행하면서도 의미 있는 동작은 돌려보지 않을 수 있다.
- 커버리지 자체가 목표가 되서는 안된다.
- **검사해야 할 행위에 집중해야 한다**

---
### 11.3 구글 규모의 테스트
> 구글은 모든 코드를 모노 리포에서 관리한다!!! 매주 약 2천 5백만 라인이 변경된다!!!
> 이를 통해서, 다른 이가 소유한 코드를 변경해 함께 개선하는 일이 흔하다.

#### 11.3.1 대규모 테스트 스위트의 함정
> 예상 결과를 너무 세세하게 표현하거나 광범위하고 복잡한 상용구가 덕지덕지한 테스트는 자동화를 막는다.

- 깨지기 쉬운 테스트로 인한 저항
- 테스트 스위트 크기의 증대로 인한 수행시간의 증가
- 비결정적이고 느려지는 테스트 스위트는 생산성을 갉아먹는다.
- 테스트 스위트를 잘 관리하는 가장 효과적인 비결은 **테스트를 존중하는 문화**다.

---
### 11.4 구글의 테스트 역사
> '오리엔테이션 수업', '테스트 인증 프로그램', '화장실에서도 테스트'

#### 11.4.1 오리엔테이션 수업
> OJT를 통해 자동 테스트의 가치를 이야기하기 시작함

#### 11.4.2 테스트 인증
> 테스트 인증 프로그램을 통해서 각 팀 및 자신의 테스트 프로세스 수준을 알게하고 더 나아가기 위해 만든 지침

#### 11.4.3 화장실에서도 테스트

---
### 11.5 자동 테스트의 한계
> 검색 결과의 품질을 테스트하려면 사람의 판단이 개입되어야 한다. 이와 같이 여러 분야에서 자동화로 테스트할 수 없는 부분들이 존재한다.

- **탐색적 테스팅**: 창의력을 요구하는 작업으로 검사 대상을 마치 고장내야 할 퍼즐로 취급함.

