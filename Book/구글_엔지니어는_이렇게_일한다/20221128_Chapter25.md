> 2022년 11월 28일(월) 10:30 - Chapter 24

# Chapter 25. 서비스형 컴퓨트
> 열심히 작성한 코드를 작성했다면 실행해줄 하드웨어가 필요하다. 이 하드웨어를 구입하거나 임대하는 것이
> 서비스형 컴퓨트(CaaS, Compute as a Service)의 본질이다.

- 내 프로그램을 실행해줄 하드웨어를 주세요 > 조직의 발전과 성장에 발맞추어 확장되어 나가는 시스템

---
### 25.1 컴퓨트 환경 길들이기
#### 25.1.1 힘든 일은 자동으로
- 2000년 전후 : SFTP
  - 특정 컴퓨터에 SSH로 접속해 코드를 컴파일해 실행
  - 컴퓨터가 많아지면 SFTP와 SSH 접속 부분을 스크립트로 자동화 하게 될 것
> 머신 중 하나가 고장나면 작업을 다른 머신으로 자동으로 이전하여 수행할 방법이 없고, 작업 진척 상황을 모니터링하는
> 일 역시 임시방편적인 형태이다. 

**간단한 자동화**
- 하나의 머신에 바이너리를 배포하고 시작시키는 과정은 셸 스크립트로 쉽게 자동화할 수 있음
  - 더 나아가 유지보수가 쉬운 언어로 병렬 실행 스크립트를 작성할 수 있음
  - 모니터링하는 일도 자동화할 수 있음
- 하지만 사람이 구현한 머신 사용량 제한 메커니즘이나 새 머신으로의 작업 이전 등을 위해서는 더 복잡한 해법이 필요함.

**스케줄링 자동화**
- 머신을 할당하는 부분을 자동화하는 것으로 진짜 '서비스'가 필요한 단계
- 조건
  - 사용 가능한 머신의 전체 목록을 알고 있어야 한다.
  - 요청 시 미사용 머신을 선태갛여 제품 바이너리를 자동으로 배포한다.
- 스케줄링 자동화와 장애 머신 감지 기술을 통해 자동화를 구현할 수 있다.
  - 구글에서는 이것을 Global WorkQueue 라는 CaaS를 만들어서 사용함

#### 25.1.2 컨테이너화와 멀티테넌시
1. 일반적으로 머신의 종류보다 작업의 종류가 훨씬 많음
2. 프로그램 자원 요구사항은 시간이 갈수록 늘어나지만 머신을 새로 구비하는 데는 시간이 걸림
3. 새 머신들이 구비되더라도 옛 머신들을 바로 처분하기는 어려움

> 효과적인 해결책은 스케줄러가 머신 풀에서 여유 있는 머신을 선택하여 프로그램을 채워 넣는 방식

**옆집 개가 내 RAM에서 짖다**
> 한정된 CPU 자원에서 특정 프로그램이 더 많은 자원을 소비하기 시작한다면 끔찍하게 늘어나는 지연시간을 경험할 수 있다.
>
> /tmp 디렉토리와 같은 전역 자원의 공유라던가, 보안 이슈가 발생할 수 있다.

- 멀티테넌트(multi-tenant) 서비스는 테넌트들을 일정 수준 격리해 보호해줘야 한다.
- VM(Virtual Machine)
  - 부하가 크다는 이슈가 있음.
  - 운영체제를 돌려야 해서 자원 소모율이 높으며 부팅을 위한 구동 시간도 느리다.
- 이러한 한계로 구글의 Borg도 컨테이너로 진화함
  - cgroups, chroot jail, bind 마운트, union/overlay 파일시스템 등을 이용
  - 오픈소스: Docker, LMCTFY 등..

**적정 규모화와 자동 확장**
> 2006년 Borg는 엔지니어들이 설정 정보로 제공한 매개변수(복제본 개수, 자원 요구사항)들을 보고 작업을 스케줄링 했음

- 이는 신뢰도가 떨어지며, 날이 갈수록 효율을 떨어뜨리는 원인으로 변해감
  - 매개변수 산정에 비용이 들어가고, 누락된 경우 운영 중단 발생 가능
- 매개변수 설정 자동화
  - 어려움. 하지만 필요하긴 함

#### 25.1.3 요약
- 조직이 커지고 제품들이 많이 사용될 수록 아래 요인 모두 증가함
  - 관리해야 할 애플리케이션의 종류
  - 운영해야 할 애플리케이션 복제본의 수
  - 가장 큰 애플리케이션의 크기

---
### 25.2 관리형 컴퓨트에 적합한 소프트웨어 작성하기
> 자동화된 스케줄링과 적정 규모화로 인해 인프라 관리가 쉬워졌으며, 소프트웨어를 바라보는 시각과 작성하는 방식에도 변화가 생김

#### 25.2.1 장애를 감안한 아키텍처 설계
> 반려동물 vs 가축

- **반려동물**
  - 문제가 생길 때마다 달려와 보살펴야 한다. 무엇이 문제인지 확인하여 회복하도록 해야함
  - 유지보수 부담은 서버 수에 비례해서 혹은 그 이상으로 커짐
- **가축**
  - 복제본으로 이름을 짓고, 하나가 실패하면 자동화 시스템이 제거한 후 새로운 서버를 프로비전해 줄 것임.
  - 문제가 발생한 경우 인스턴스를 찍어내기 쉽다는 것
  - 장애가 자동으로 복원될 수 있음
- 하지만 가축이 된다 해서 문제없이 동작한다고 보장할 수는 없음
  - 문제가 생기더라도 효과적으로 동작할 수 있도록 아키텍처 설계가 필요함

#### 25.2.2 배치 vs 서빙
- **배치 작업**
  - 데이터 처리 같은 정해진 테스크를 완료해야 하는, 끝이 있는 프로그램(로그 분석, 머신러닝 모델 학습)
  - 처리량(throughput)이 중요
  - 수명이 짧음
  - 작업을 작은 뭉치로 분산한 다음 워커들에게 동적으로 할당할 수 있어야 함
  - Flume
- **서빙 작업**
  - 끝없이 계속 실행되면서, 들어오는 요청을 그때그때 처리(웹 검색)
  - 지연시간(latency)가 중요
  - 대체로 오래 지속
  - 구동되는데 오래 걸릴 수 있음
  - 작업이 자연스럽게 작은 조각들로 나뉘어 있으며 워커들에 동적으로 할당 됨

#### 25.2.3 상태관리
> 서버 중 한 대를 교체할 때 마다 처리 중인 모든 상태를 잃게된다. 처리 중인 상태 역시 휘발성으로 취급해야 하며, '진짜 스토리지'는 다른 곳에 둬야 한다.

1. 외부 스토리지 사용하기
   1. 하나의 요청이나 하나의 데이터 뭉치 처리범위를 넘어 존재해야 하는 모든 데이터는 견고한 외부 영구 스토리지에 저장하기
   2. 현실적이지 않음
   3. 영구 스토리지도 가축처럼 취급하여 상태를 복제하면 상태도 가축처럼 관리할 수 있음
   4. RAID와 비슷함 - 디스크 중 하나가 깨질 것을 대비해 여러 디스크에 데이터를 복제해 둠
2. 데이터 조각을 소유한 복제본을 여러 벌 만들어 동기화 시켜서 결국 모든 데이터 조각이 충분한 개수만큼 존재하도록 만들면 됨
   1. '다시 만들 수 있는' 데이터라면 로컬 스토리지를 응용할 수 있게 된다.
   2. 지연시간 목표를 달성하기 위해 캐시를 이용하되, 핵심 애플리케이션은 캐시 없이도 전체 부하를 감당할 수 있게 준비해둬야 함.
   3. 외부 스토리지의 데이터를 로컬로 가져와도 서빙 작업의 지연시간을 줄일 수 있음
   4. 로컬 스토리지를 이용해 배치 쓰기 작업을 진행할 수도 있음

#### 25.2.4 서비스에 연결하기
> 애플리케이션이 구동되는 호스트의 이름을 하드코딩해뒀다면 이 복제본은 더 이상 가축이 아니게 됨.

- 서비스 디스커버리 - registar
  - 간접 참조 계층을 추가하여, 식별자를 이용해서 백엔스 인스턴스가 다른 머신에서 다시 시작되어도 연결될 수 있게 해야 함.
  - 대화 중인 서버가 응답 전에 장애가 날 수 있으므로 요청을 다시 보내야 할 수도 있음
    - 백오프(backoff), 단계적 성능 감소(graceful degradation), 지터(jitter)와 같은 연쇄 장애 방지 대책이 필요함
  - 같은 요청을 두 번 보내도 한 번 보냈을 때와 같은 결과를 내주고 서버의 상태도 동일하게 남아야 하는, **멱등성**을 보장해야 함

#### 25.2.5 일회성 코드
> 일회성 분석, 탐색용 프로토타이핑, 맞춤형 데이터 처리 파이프라인 등의 일회성 업무들을 처리해야 할 수도 있음

- 1GB 의 로그를 분석하는 것과 1TB의 로그를 분석하는 것은 차이가 있다.
  - 컴퓨트 파워가 필요할 때!
- 작업을 처리하는 데 드는 컴퓨트 자원의 비용이 엔지니어의 시간보다 비싼 경우는 흔치 않다.
  - 엔지니어별로 자원 사용량을 제한하여 너무 많은 컴퓨트 자원을 들고 오지 않도록 하는 방법도 있음

---
### 25.3 시간과 규모에 따른 CaaS
#### 25.3.1 추상화 수단으로써의 컨테이너
> 컨테이너는 멀티테넌시를 가능케 해주는 주요한 격리 메커니즘으로, 하나의 머신을 공유하면서 서로의 간섭을 최소로 줄여줌.

- 배포된 애플리케이션과 이를 실행하는 머신 사이에 추상화 계층을 한 겹 씌워줌
- 파일시스템을 추상화하면 의존성을 관리하기 쉬워짐
  - 소프트웨어 구동에 필요한 의존성을 미리 선언하고 패키징할 수 있기 때문
- 이름 있는 자원도 쉽게 관리할 수 있음

**컨테이너와 암묵적 의존성**
- 암묵적 의존성으로 옭아매는 하이럼의 법칙은 컨테이너 추상화에도 영향을 미침. 그것도 더 강하게
  - 이용자 수가 더 많기 때문
  - 실제로는 API를 호출한다는 사실을 인지하지 못하기 때문

#### 25.3.2 모든 작업을 하나의 아키텍처로
> 구글은 기존에 배치작업과 서빙작업을 위한 아키텍처가 상이했고, 이를 거대한 풀로 통합하는 방향으로 가서 출범한 것이 Borg

1. 서빙 머신이 가축이 됨
   1. '머신에는 이름이 없다. 프로그램은 요구조건만 충족한다면 어느 머신에서 구동되는지 개의치 않는다.'
   2. 규모가 늘어도 비용이 증가하지 않는다. 
2. 배치작업과 서빙작업의 효율적인 자원배분이 가능해진다.

**서빙 작업을 위한 멀티테넌시**
> 관리형 컴퓨트 시스템을 서빙작업에까지 확장하려면 몇 가지 새로운 요구사항을 충족시켜야 한다.

- 작업 스케줄링 규모를 제한해야 함.
- 배치 작업은 일반적으로 경고 없이 종료해도 괜찮음

#### 25.3.3 표준 설정 언어
- 물리적으로 사용자와 가까이 두거나 장애에 대비하기 위해 여러 데이터센터로 분산해야 함
- 프로덕션 환경뿐 아니라 스테이징과 데브 환경도 관리해야 함
- memcached와 같이 서비스를 개선해주는 새로운 유형의 복제된 컨테이너가 추가될 수 있음

---
### 25.4 컴퓨트 서비스 선택하기
> 컴퓨트 인프라는 강력한 종속 요인임을 감안하여 선택해야 한다.

- 컴퓨트 서비스를 둘러싼 생태계가 계속 확장된다는 점 역시 컴퓨트 서비스를 교체하기 어렵게 만드는 주된 원인.
  - 로깅, 모니터링, 디버깅, 경보, 시각화, 실시간 분석, 설정 언어와 메터언어, 사용자 인터페이스 등

#### 25.4.1 중앙 관리 vs 사용자화
> 조직 전체에서 하나의 CaaS만 이용하는게 가장 좋음

#### 25.4.2 또 다른 수준의 추상화: 서버리스
> 추상화 수준을 가장 높이게 된다면 서버리스를 만나게 된다.
>
> VM > 컨테이너 > 서버리스

- 웹 컨텐츠를 서비스하는 조직에서 공통 서버 프레임워크를 이용해 HTTP 요청과 응답을 처리한다고 가정
  - 프레임워크의 핵심적 특징은 제어 반전(IOC, Inversion of control)이다.
    - 프레임워크 이용자가 할 수 있는 일은 일종의 액션이나 핸들러를 제작해 넣는 것 뿐
  - 멀티테넌트를 머신 차원이 아닌 프레임워크 서버 자체에서 지원하는 방식
    - 프레임워크 서버를 더 많이 실행시켜두고, 필요에 따라 다른 서버의 함수 코드를 동적으로 로드/언로드하며, 필요한 함수가 로드되어 있는 서버로 동적으로 요청을 보내 처리

- **장점과 단점**
  1. 서버리스 아키텍처를 이용하기 위해서는 코드에 상태가 전혀 없어야 함.
     1. 사용자의 VM을 실행하거나 Cloud Spanner 같은 데이터베이스를 구현할 수 없음
     2. 필요한게 있다면 하나의 요청 범위 안에서 모두 설정해야 함
  2. 관리형 서버리스 모델은 트래픽이 적을 대 자원 비용을 유연하게 가져가는데 유리함
  3. 환경에 대한 통제력을 일부 잃게 됨
     1. 관리 부담이 줄어들 수는 있으나, 통제가 필요한데 통제하지 못하면 문제가 생길 수 있음

- **트레이드오프**
  - 구글의 Borg는 서버리스가 주는 이점 대부분을 제공할 만큼 발전함
    - 자동확장에서는 조금 열세
  - 모든 것을 소화할 수 있는 하나의 통합 아키텍처를 추구하기보다는 일부 유형의 작업용으로 서버리스 스택을 따로 두는 것이 유리하다
- 서버리스는 대규모 조직보다는 작은 조직이나 팀에 더 와닿음
  - 조직이 성장하고 관리형 기술을 더 많이 활용하게 되면 순수 서버리스 서비스의 제약이 족쇄가 되기도 함

#### 25.4.3 공용 vs 사설
> 머신을 임대할 것이냐 소유할 것이냐

- 공용 클라우드
  - 관리 부담이 줄어듬
  - 인프라를 확장하기 쉬워짐
  - 해당 업체에 종속된다는 리스크가 존재
    - 쿠버네티스 같은 오픈 소스 제품을 올리면 종속 위험을 완화할 수 있음
    - 현재 이용하는 인프라에서 다른 곳으로 마이그레이션 할 수 있는 길을 열어두는 것
- **저수준 공용 클라우드 위에 고수준 오픈 소스 제품 얹기**
  - 아마존 EC2 위에 OpenWhisk나 Knative 올리기
- **여러 클라우드 혼용하기**
  - 하이브리드 클라우드 / 일부는 사설, 일부는 공용(마이그레이션 부담이 늘어남)
    - 트래픽이 치솟을 때 공용에 의뢰하는 방식으로 사용됨



