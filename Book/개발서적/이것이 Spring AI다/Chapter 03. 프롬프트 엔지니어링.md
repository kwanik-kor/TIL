## 1. 프롬프트 템플릿

프롬프트란 AI 모델, 특히 LLM에게 사용자가 원하는 작업을 구체적으로 지시하거나 질문의 형태로 요구사항을 전달하는 일종의 명령문으로, "어떤 상황에서", "무엇을", "어떤 형식으로" 응답해야 하는지를 알려주는 중요한 역할을 한다.

- `SystemMessage`
	- LLM의 행동과 응답 스타일을 지시하는 메시지. LLM이 입력을 해석하는 방법과 답변하는 방식 지시
- `UserMessage`
	- 사용자의 질문, 명령을 담고 있는 메시지
- `AssistantMessage`
	- LLM의 응답 메시지로, 대화 기억 유지에 사용되어 일관되고 맥락에 맞는 대화에 도움을 줌

단순한 문자열이 아닌 동적 텍스트 바인딩이 가능한 Prompt Template을 제공함

```java
PromptTemplate template = PromptTemplate.builder()
	.template("{topic}에 대한 농담 {num}개를 목록으로 출력해 줘.")
	.build();
	
Prompt prompt = template.create(Map.of("topic": "AI", "num": 3))
```


## 2. 프롬프트 엔지니어링

**프롬프트 엔지니어링 기본 가이드**

| 기본 원칙               | 설명                                                         |
| ------------------- | ---------------------------------------------------------- |
| 명확하고 구체적인 요청        | 프롬프트는 모호하지 않고 구체적이어야 한다. 원하는 답변의 범위와 방향을 명확히 정의해야 한다.      |
| 모델의 이해를 돕는 배경 정보 제공 | 답변을 더 정확히 이해할 수 있도록 사용자 메시지에 배경 정보나 문맥 제공                  |
| 간결하고 직관적인 문장 사용     | 모호하고 수식어가 많은 복잡한 문장보다는, 간단하고 직관적인 문장 사용                    |
| 적절한 예시 사용           | 사용자가 원하는 스타일이나 출력 형식을 정확히 이해할 수 있도록 예시를 포함하는 것이 좋음         |
| 다단계 질문 피하기          | 여러 질문을 한 프롬프트에 담지 말고, 하나의 질문에 집중하여 LLM이 정확한 답변을 할 수 있도록 유도 |
| LLM의 한계 이해          | LLM이 처리할 수 있는 범위와 한계를 이해하고, 그에 맞는 프롬프트를 설계해야 함             |
| LLM의 역할 부여하기        | 명확한 역할을 부여하여 특정 작업에 집중하게 해야 함                              |

### 2.1 제로-샷 프롬프트(zero-shot prompt)

AI에게 예시 없이 작업을 수행하도록 요청하는 방법으로, 모델이 처음부터 지시를 이해하고 실행할 수 있는 능력이 있을 경우에 사용가능

```text
# 예시 - LLM은 이미 번역/요약/분류와 같은 작업이 무엇인지 잘 알고 있기 때문

영화 리뷰를 [긍정적, 중립적, 부정적] 중에서 하나로 분류하세요.
레이블만 반환하세요.
리뷰: {review}
```

### 2.2 퓨-샷 프롬프트(few-shot prompt)

LLM에게 몇 개의 예시를 제공하여 사용자가 원하는 방식으로 출력하도록 유도하는 기법으로, 한 개의 예시를 제공하는 것을 원-샷이라고 함. 많은 데이터를 학습한 LLM 이지만, 어떤 방식으로 답변해야 하는지에 대한 명확한 기준이 없으므로 사용자가 원하는 형식을 학습시켜 동일한 답변 형식을 유도하는 것

```text
# 예시

고객 주문을 유효한 JSON 형식으로 바꿔주세요.  
추가 설명은 포함하지 마세요.  
  
예시1:  
작은 피자 하나, 치즈랑 토마토 소스, 페퍼로니 올려서 주세요.  
JSON 응답:  
{  
  "size": "small",  "type": "normal",  "ingredients": ["cheese", "tomato sauce", "pepperoni"]}  
  
예시1:  
큰 피자 하나, 토마토 소스랑 바질, 모짜렐라 올려서 주세요.  
JSON 응답:  
{  
  "size": "large",  "type": "normal",  "ingredients": ["tomato sauce", "basil", "mozzarella"]}  
  
고객 주문: %s
```

### 2.3 역할 부여 프롬프트

특정 역할이나 인물을 맡도록 지시하면 출력 결과에 영향을 미치는데, 특정 정체성, 전문성 또는 관점을 부여하여 출력 내용의 스타일, 톤, 깊이를 조정할 수 있다.

```text
# 예시

당신이 여행 가이드 역할을 해 주었으면 좋겠습니다.  
아래 요청사항에서 위치를 알려주면, 근처에 있는 3곳을 제안해 주고,  
이유를 달아주세요. 경우에 따라서 방문하고 싶은 장소 유형을 제공할 수도 있습니다.  
출력 형식은 <ul> 태그이고, 장소는 굵게 표시해 주세요.
```

### 2.4 스탭-백 프롬프트(Step-back prompt)

복잡한 질문을 여러 단계로 분해해, 단계별로 배경 지식을 확보하는 기법으로, LLM이 즉각적인 답변을 생성하기 전에 문제와 관련된 폭넓은 배경 지식을 갖도록 유도하는 방법.

```text
사용자 질문을 처리하기 Step-Back 프롬프트 기법을 사용하려고 합니다.  
사용자 질문을 단계별 질문들로 재구성해주세요. 맨 마지막 질문은 사용자 질문과 일치해야 합니다.  
단계별 질문을 항목으로 하는 JSON 배열로 출력해 주세요.  
예시: ["...", "...", "...", ...]  
사용자 질문: %s
```


### 2.5 생각의 사슬 프롬프트(Chain of Thought Prompt)

LLM에게 문제를 해결하는 과정을 명시적으로 요청하거나 논리적인 단계로 생각하도록 요구함으로써, 다단계 추론이 필요한 작업에서 성능을 향상시킬 수 있음. 최종 답을 도출하기 전에 중간 추론 단계를 생성하도록 유도함으로써, 모델의 사고 과정을 명확하게 만들게 되는 것!

```text
%s  
한 걸음씩 생각해 봅시다.  
  
[예시]  
질문: 제 동생이 2살일 때, 저는 그의 나이의 두 배였어요.  
지금 저는 40살인데, 제 동생은 몇 살일까요? 한 걸음씩 생각해 봅시다.  
  
답변: 제 동생이 2살일 때, 저는 2 * 2 = 4살이었어요.  
그때부터 2년 차이가 나며, 제가 더 나이가 많습니다.  
지금 저는 40살이니, 제 동생은 40 - 2 = 38살이에요. 정답은 38살입니다.
```

### 2.6 자기 일관성(Self-consistency)

LLM에게 여러 번 요청해서 얻은 응답을 집계하여 다수결로 최종 응답을 정하는 기법으로 LLM이 일관성 있게 응답하는 것을 채택하는 방법이다. 

[소스 코드 참고](https://github.com/kwanik-kor/playground/blob/main/spring-ai/src/main/java/com/gani/springai/service/PromptTemplateService.java)

----

## 스터디 첫 번째 시간

- 일시: 2025.09.16 22:00
- 장소: zoom

인공지능 모델 연구에 있어서 huggingface와 같은 모델들은 파이썬으로 구성되어 있어서, 모델 연구에 유리한 부분들이 있음. 하지만 어플리케이션을 만드는 입장에서는 어플리케이션 생태가 잘 되어 있는 환경으로 구성하는 것이 보다 유리하다고 볼 수 있음.

### 1. 환경설정

- `spring-ai-starter`가 붙은 아이들만 사용할 것
	- spring-ai-bom에서 모든 서브 모듈의 버전을 관리함
	- 이 모듈만 bom 적용이 되기 때문
- 공급사(openai, gemini, anthropic, ...)별로 지원되지 않는 모델은 감지할 수 있음
- 다양한 공급사를 사용하려면 exclude로 자동설정을 막고 수동빈
- 실무에서는 여러 공급사를 동시 제공하는 경우가 빈번
	- 대부분 exclude로 수동 빈 구성하게 됨
```yaml
spring:
	autoconfigure:
		exclude:
			- org.springframework.ai.autoconfigure.
			- org.springframework.ai.autoconfigure.
			- org.springframework.ai.autoconfigure.
			  
```

### 2. ChatCompletion

> Open AI에서 공식적으로 제공하는 API 이름이기도 하며, A -> B의 학습 쌍이 이루어졌다는 것을 의미함

- 최신 모델은 대부분 다음의 completion으로 학습
	- system
	- user
	- assistant
- RLHF 등의 튜닝에서도 동일 구조로 학습
- 학습을 2인 대화로 했기 때문에 3인 이상의 화자는 잘 인식하지 못함
- 멀티턴 처리도 컨텍스트로 인식되게 대부분 학습됨
	- user, assi, user, assi, user
- 