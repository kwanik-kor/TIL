> 마이크로서비스의 도입으로 인한 빈번한 내부 연동 및 점점 복잡해져 가는 시스템 아키텍처로 외부 연동 역시 빈번해지고 있다. 우리 시스템이 부하를 감당할 수 있다 하더라도, 외부 시스템에 의한 장애 전파는 더 큰 장애로 이어질 수 있으므로 외부 연동에는 늘 주의를 기울여야 한다.

## 1. 타임아웃

외부 연동 서비스에 대하여 적절한 타임아웃을 설정하지 않을 경우, 연동 서비스의 응답이 느리면 처리량이 급격히 떨어질 수 있다. 요청 대기 시간이 늘어날 뿐 아니라, 요청 대기 시간으로 인한 사용자들의 새로고침이 발생하고 이는 요청 수를 기하급수적으로 늘릴 수 있다.

ex) A 서비스 스레드 풀 200개, B 서비스 응답 대기

### 1.1 연결 타임아웃(connection timeout), 읽기 타임아웃(read timeout)

API 연동 통신과정은 간단하게 `연결 > 요청 > 응답 > 종료`의 단계를 거치게 된다.

- 네트워크 연결(3 ~ 5s)
	- 네트워크 상황이나 연결할 서버 상태에 따라 연결에 시간이 오래 걸릴 수 있음
	- 연결 타임아웃(connection timeout)을 설정해 연결 대기 시간을 제한해야 함
- 요청 / 응답(5 ~ 30s)
	- 요청에 대한 응답을 받기까지 시간이 오래 걸리면 대기 시간이 발생할 수 있음
	- 읽기 타임아웃(read timeout)을 설정해 응답 대기 시간을 제한해야 함
	- 실제로 설정하는 값이 무엇인지 잘 확인해야 함
		- Apache HttpClient: Socket timeout
			- 네트워크 패킷 단위를 기준으로 함에 따라, 전체 응답 시간에 대한 타임아웃이 아님
		- OkHttp: call timeout
			- 요청 시작부터 응답까지의 전체 시간 기준으로 설정

## 2. 재시도

간헐적으로 연결에 실패하거나 일시적으로 응답이 느려진 경우, 재시도를 통해 연결 실패를 성공으로 바꿀 수 있음

### 2.1 재시도 가능 조건

> 단, 연동 API를 다시 호출해도 되는 조건인지 반드시 확인해야 한다.

- 단순 조회 기능
- 연결 타임아웃
- 멱등성(idempotent)을 가진 변경 기능
	- 읽기 타임아웃(read-timeout)인 경우 연동 서비스가 요청을 처리하고 있을 수 있으므로 재시도에 주의해야 함
		- 연산을 여러번 적용해도 결과가 달라지지 않는 멱등성을 가진 API만 호출해야 함
	- 실패 원인에 따라 재시도 여부를 결정해야 함. 검증 오류라면 또 요청해도 의미 없음

### 2.2 재시도 횟수와 간격

재시도 횟수
- 재시도 횟수만큼 응답 시간도 함께 증가할 수 있으므로, 대부분 1~2번 정도가 적당

재시도 간격
- 바로 재시도를 할 경우, 동일한 원인으로 오류가 발생할 수 있음
- 일정한 간격을 두거나, 점진적으로 늘려가며 부하를 완화할 수 있음(resilience4j)

### 2.3 재시도 폭풍(retry storm) 안티패턴

재시도를 통해 성공 가능성을 높일 수 있지만, 반대로 연동 서비스에는 더 큰 부하를 줄 수 있음. 이에 따라 연동 서비스의 성능 상황도 함께 고려해야 함


## 3. 동시 요청 제한

순간적인 트래픽이 몰리면, 연동 서비스의 최대 처리량을 초과하여 우리 서비스에도 지장이 발생할 수 있음. 연동 서비스에 임계치 이상의 요청을 보냄에 따라 발생하는 문제는 연동 서비스에 **일정 수준 이상으로 요청을 보내지 않음으로써 해결할 수 있다.**

**벌크헤드 패턴**
- 동시 요청 개수 제한으로 인해 초과된 요청 건에 대해서는 즉시 오류를 발생시키는 것
- 연동 서비스 호출 기능은 오류가 발생하지만 그렇지 않은 기능은 정상 동작

## 4. 서킷 브레이커

일종의 누전 차단기인 서킷 브레이커는 요청 서비스가 정상적인 기능을 하지 못하고 있을 때(과도한 오류 발생), 연동을 중지시키고 바로 에러를 응답한다. 

**닫힘(Closed)**
- 모든 요청을 연동 서비스에 전달

**열림(Open)**
- 실패 건수가 임계치를 초과하면 열림상태로 변경
	- 시간 기준 오류 발생 비율: 10초 동안 오류 비율이 50% 초과
	- 개수 기준 오류 발생 비율: 100개 요청 중 오류 비율이 50% 초과
- 바로 에러 응답 리턴

**반 열림(Half-Open)**
- 열림상태가 지정 시간 유지되면 반 열림 상태로 전환
- 일부 요청에 한해 연동 시도

## 5. 외부 연동과 DB 연동

> 외부 연동과 DB 연동을 함께 실행할 때는, 오류에 따른 DB 트랜잭션 처리 방법이 중요

- 외부 연동에 실패했을 때 트랜잭션을 롤백
	- 트랜잭션 범위 내에서 실패한 경우 DB 롤백이 가능하다.
	- 단, 읽기 타임아웃이 발생해서 롤백하는 경우, 외부 서비스가 실제로 성공적으로 처리했을 가능성이 있음
		- 일정 주기로 두 시스템 데이터가 일치하는지 확인하고 보정
		- 성공확인 API를 호출하는 방식
		- 일정 시간 후에 취소 API를 호출하는 방식

- 외부 연동은 성공했지만 DB 연동에 실패해 트랜잭션을 롤백
	- 취소 API를 호출해 외부 연동을 이전 상태로 되돌려야 함

트랜잭션 범위 내에서 외부 연동이 느려지면 커넥션 풀이 부족해질 수 있다.
- 커넥션 풀에서 커넥션을 가져온다.
- 0.1초 걸리는 DB 쿼리를 실행한다.
- 외부 연동 API를 호출(API 실행에 4.8초 소요)한다.
- 0.1초 걸리는 DB 쿼리를 실행한다.
- 커넥션을 풀에 반환한다.
-> 커넥션을 사용하지 않아도 점유하고 있는 상태

외부 연동을 트랜잭션 범위 밖에서 실행하는 경우, 외부 연동 실패에 따른 롤백이 불가능함에 따라 보상 트랜잭션을 사용하거나 기능 특성에 따라 데이터를 후보정하는 방법을 채택해야 함.

## 6. HTTP 커넥션 풀

> DB 커넥션풀을 사용하듯 HTTP 연결도 커넥션 풀을 사용하여 연결 시간을 줄일 수 있음

- HTTP 커넥션 풀의 크기
	- 연동할 서비스의 성능에 따라 결정
- 풀에서 HTTP 커넥션을 가져올 때까지 대기하는 시간
	- 커넥션 반환 대기 시간은 수 초 이내의 짧은 시간으로 설정(1~5s)
- HTTP 커넥션을 유지할 시간(keep alive)
	- keep-alive 헤더로 연결 유지 시간을 지정하므로, 클라이언트 커넥션 풀도 이 값보다 오래 유지하면 안됨

## 7. 연동 서비스 이중화

핵심 서비스를 이중화하여 안정성을 고려해볼 수 있음
- 해당 기능이 서비스의 핵심인가(e.g, 쇼핑 > 결제)
- 이중화 비용이 감당 가능한가

---
### 심화 학습

1. 벌크헤드 패턴은 어떻게 구현할 수 있을까?
2. Resilience4j 를 이용한 재시도 전략을 알아보자.
3. 서킷 브레이커에 대해서 조금 더 알아보자
	1. 단일 API만 제공되고 있는 경우?
	2. 의도적으로 실패 API 요청 공격이 들어올 경우


