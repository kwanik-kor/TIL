> 기능을 개발할 때 기능의 실행 순서에 따라 프로그램을 작성하고 실행하면 동기(synchronous) 방식으로 동작한다. 즉, A가 B를 호출하는 로직이 있다고 가정했을 때, A는 B의 작업이 완료될 때까지 기다려야 한다. 하지만 B 서비스가 연동 서비스고 B 서비스에 이슈가 발생했다면?

다음 작업을 위해 반드시 호출한 작업의 결과가 필요한 것이 아니라면 비동기(asynchronous) 방식 채택을 고려해볼 수 있다.
- 연동에 약간의 시차가 발생행도 문제가 되지 않는 경우
- 일부 기능이 실패해도 재시도가 가능한 경우
- 연동에 실패했을 때 나중에 수동으로 처리할 수 있는 경우
- 연동에 실패했을 때 무시해도 되는 기능

## 1. 별도 스레드로 실행하기

스레드를 생성하거나, 스레드 풀을 이용하거나 혹은 프레임워크에서 제공하는 비동기 기능(e.g., @Async)을 사용해서 처리한다.

단, 별도 스레드로 연동할 경우 오류 처리에 대해 더 신경을 써줘야 한다. 

Exception 전파가 소용없기 때문!

## 2. 메시징

서로 다른 시스템 간 비동기 연동을 위해 주로 메시징 시스템을 사용한다.
- 두 시스템이 서로 영향을 주지 않는다.
	- A 시스템 트래픽 급증 시, B 시스템 성능 저하로 인한 장애 전파가 일어나지 않음
- 확장이 용이하다.
	- A 시스템이 C 에도 데이터를 전송해야 한다면, C를 메시지 시스템에 연결만 하면 됨

카프카(Kafka)
- 높은 처리량, 초당 백 만 개 이상의 메시지를 처리할 수 있음
- 수평 확장이 용이. 서버(브로커), 파티션, 소비자를 늘리면 됨
- 카프카는 메시지를 파일에 보관해서 유실되지 않음
- 1개의 토픽이 여러 파티션을 가질 수 있는데, 파티션 단위로 순서를 보장. (토픽 수준에서는 순서 보장 X)
- 소비자는 메시지를 언제든지 재처리 가능
- **풀(pull) 모델** 사용, 소비자가 카프카 브로커에서 메시지를 읽어 가는 방식

Rabbit MQ
- 클러스터를 통해 처리량을 높일 수 있다. 단, 카프카보다 더 많은 자원을 피룡로 함
- 메모리에만 메시지를 보관하는 큐 설정을 사용하면 장애 상황 시 메시지가 유실될 수 있음
- 메시지는 큐에 등록된 순서대로 소비자에 전송
- 메시지가 소비자에 전달됐는지 확인하는 기능 제공
- **푸시(push) 모델** 사용, Rabbit MQ 브로커가 소비자에게 메시지를 전송함. 소비자의 성능이 느려지면 큐에 과부하가 걸려 전반적으로 성능 저하가 발생할 수 있음.
- 다재 다능. AMQP, STOMP 등 여러 프로토콜을 지원하고, pub/sub 패턴 뿐만 아니라 요청/응답, 점대점패턴을 지원함. 우선순위를 지정해서 처리 순서를 변경할 수 있음

레디스 pub/sub
- 메모리를 사용하므로 지연 시간이 짧고, Rabbit MQ 대비 처리량이 높다.
- 구독자가 없으면 메시지가 유실된다.
- 기본적으로 영구 메시지를 지원하지 않는다.
- 모델이 단순해서 사용하기 쉽다.

> 기술을 선택할 때는 개인의 호기심이나 취향보다는 조직의 역량과 지속 가능성을 고려해야 함

### 2.1 메시지 생산자 측 유의할 점

**메시지 유실**
- 무시하기
	- 단순 로그 메시지인 경우 유실되어도 됨
- 재시도하기
	- 일시적 오류는 재시도를 통해 해결될 수 있음
- 실패 로그 남기기
	- 실패 로그를 남겨 후처리 진행


**DB 트랜잭션**
메시지 전송 후 DB 트랜잭션이 롤백되면 잘못된 메시지가 전송될 수 있음. 트랜잭션이 끝난 뒤에 메시지 전송하는 것이 좋음

### 2.2 메시지 소비자 측 유의할 점

- 메시지 생산자의 중복 메시지 발행
	- 메시지에 고유 ID를 부여하여 처리 여부를 추적
- 소비자가 메시지를 처리하는 과정에서 오류가 발생하여 재수신
	- API의 멱등성 보장, 동일 요청에 대한 중복 처리를 해도 결과는 일치

### 2.3 이벤트와 커맨드

**이벤트(Event)**
- 어떤 일이 발생했음을 알려주는 메시지(e.g., "주문함", "로그인에 실패함")
- 상태 변경과 관련있거나, 어떤 활동이 일어났다는 사실을 나타냄
- 정해진 수신자가 없음
- thqlwk ghkrwkddp wjrgkq

**커맨드(Command)**
- 무언가를 요청하는 메시지(e.g, "포인트 지급하기", "로그인 차단하기")
- 메시지를 수신할 측의 기능 실행에 초점이 맞춰져 있음

## 3. 트랜잭션 아웃박스 패턴



---
## 심화학습

1. 왜 카프카는 Rabbit MQ와 달리 높은 처리량을 가질 수 있는걸까?
2. Pull 방식일 때, 복수의 소비자(Consumer)가 어떻게 메시지를 읽어갈 수 있을까?
3. Push 방식은 브로커가 소비자에게 메시지를 전송하는데, 어떤 소비자가 있는지 어떻게 아는걸까?
4. AMQP, STOMP 프토토콜이란?
5. 요청/응답, 점대점 패턴이란?