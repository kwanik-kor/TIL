> 기능을 개발할 때 기능의 실행 순서에 따라 프로그램을 작성하고 실행하면 동기(synchronous) 방식으로 동작한다. 즉, A가 B를 호출하는 로직이 있다고 가정했을 때, A는 B의 작업이 완료될 때까지 기다려야 한다. 하지만 B 서비스가 연동 서비스고 B 서비스에 이슈가 발생했다면?

다음 작업을 위해 반드시 호출한 작업의 결과가 필요한 것이 아니라면 비동기(asynchronous) 방식 채택을 고려해볼 수 있다.
- 연동에 약간의 시차가 발생해도 문제가 되지 않는 경우
- 일부 기능이 실패해도 재시도가 가능한 경우
- 연동에 실패했을 때 나중에 수동으로 처리할 수 있는 경우
- 연동에 실패했을 때 무시해도 되는 기능

## 1. 별도 스레드로 실행하기

스레드를 생성하거나, 스레드 풀을 이용하거나 혹은 프레임워크에서 제공하는 비동기 기능(e.g., @Async)을 사용해서 처리한다.

단, 별도 스레드로 연동할 경우 오류 처리에 대해 더 신경을 써줘야 한다. 

Exception 전파가 소용없기 때문!

## 2. 메시징

서로 다른 시스템 간 비동기 연동을 위해 주로 메시징 시스템을 사용한다.
- 두 시스템이 서로 영향을 주지 않는다.
	- A 시스템 트래픽 급증 시, B 시스템 성능 저하로 인한 장애 전파가 일어나지 않음
- 확장이 용이하다.
	- A 시스템이 C 에도 데이터를 전송해야 한다면, C를 메시지 시스템에 연결만 하면 됨

카프카(Kafka)
- 높은 처리량, 초당 백 만 개 이상의 메시지를 처리할 수 있음
- 수평 확장이 용이. 서버(브로커), 파티션, 소비자를 늘리면 됨
- 카프카는 메시지를 파일에 보관해서 유실되지 않음
- 1개의 토픽이 여러 파티션을 가질 수 있는데, 파티션 단위로 순서를 보장. (토픽 수준에서는 순서 보장 X)
- 소비자는 메시지를 언제든지 재처리 가능
- **풀(pull) 모델** 사용, 소비자가 카프카 브로커에서 메시지를 읽어 가는 방식

Rabbit MQ
- 클러스터를 통해 처리량을 높일 수 있다. 단, 카프카보다 더 많은 자원을 필요로 함
- 메모리에만 메시지를 보관하는 큐 설정을 사용하면 장애 상황 시 메시지가 유실될 수 있음
- 메시지는 큐에 등록된 순서대로 소비자에 전송
- 메시지가 소비자에 전달됐는지 확인하는 기능 제공
- **푸시(push) 모델** 사용, Rabbit MQ 브로커가 소비자에게 메시지를 전송함. 소비자의 성능이 느려지면 큐에 과부하가 걸려 전반적으로 성능 저하가 발생할 수 있음.
- 다재 다능. AMQP, STOMP 등 여러 프로토콜을 지원하고, pub/sub 패턴 뿐만 아니라 요청/응답, 점대점패턴을 지원함. 우선순위를 지정해서 처리 순서를 변경할 수 있음

레디스 pub/sub
- 메모리를 사용하므로 지연 시간이 짧고, Rabbit MQ 대비 처리량이 높다.
- 구독자가 없으면 메시지가 유실된다.
- 기본적으로 영구 메시지를 지원하지 않는다.
- 모델이 단순해서 사용하기 쉽다.

> 기술을 선택할 때는 개인의 호기심이나 취향보다는 조직의 역량과 지속 가능성을 고려해야 함

### 2.1 메시지 생산자 측 유의할 점

**메시지 유실**
- 무시하기
	- 단순 로그 메시지인 경우 유실되어도 됨
- 재시도하기
	- 일시적 오류는 재시도를 통해 해결될 수 있음
- 실패 로그 남기기
	- 실패 로그를 남겨 후처리 진행


**DB 트랜잭션**
메시지 전송 후 DB 트랜잭션이 롤백되면 잘못된 메시지가 전송될 수 있음. 트랜잭션이 끝난 뒤에 메시지 전송하는 것이 좋음

### 2.2 메시지 소비자 측 유의할 점

- 메시지 생산자의 중복 메시지 발행
	- 메시지에 고유 ID를 부여하여 처리 여부를 추적
- 소비자가 메시지를 처리하는 과정에서 오류가 발생하여 재수신
	- API의 멱등성 보장, 동일 요청에 대한 중복 처리를 해도 결과는 일치

### 2.3 이벤트와 커맨드

**이벤트(Event)**
- 어떤 일이 발생했음을 알려주는 메시지(e.g., "주문함", "로그인에 실패함")
- 상태 변경과 관련있거나, 어떤 활동이 일어났다는 사실을 나타냄
- 정해진 수신자가 없음
- thqlwk ghkrwkddp wjrgkq

**커맨드(Command)**
- 무언가를 요청하는 메시지(e.g, "포인트 지급하기", "로그인 차단하기")
- 메시지를 수신할 측의 기능 실행에 초점이 맞춰져 있음

## 3. 트랜잭션 아웃박스 패턴

잘못된 메시지 발송을 방지하기 위해 DB 트랜잭션 완료 후에 메시지를 전송한다고 하더라도, 시스템 연동에 실패하는 등 완벽하지 않을 수 있다. 메시지 데이터 자체가 유실되지 않도록 보장하기 위해서는 해당 메시지를 DB에 저장하면 되는데, 이를 **트랜잭션 아웃박스 패턴**이라고 한다.

- 실제 업무 로직에 필요한 DB 작업 수행
- 메시지 데이터 아웃박스 테이블에 추가

한 DB 트랜잭션 범위 내에서 추가하므로, 실패할 경우 같이 롤백이 됨

발송 완료 표기를 위해서는 아래 두 가지 방법 채택 가능
- 아웃박스 테이블에 발송 상태 컬럼을 두는 것
- 메시지 중계 서비스가 성공적으로 전송한 마지막 메시지 ID 기록

아웃박스 테이블 구조

| 컬럼          | 타입        | 설명                |
| ----------- | --------- | ----------------- |
| id          | big int   | 단순 증가 값(PK)       |
| messageId   | varchar   | 메시지 고유 ID(UNIQUE) |
| messageType | varchar   | 메시지 타입            |
| payload     | clob      | 메시지 데이터           |
| status      | varchar   | 이벤트 처리 상태         |
| failCount   | int       | 실패 횟수             |
| occuredAt   | timestamp | 메시지 발생 시간         |
| processedAt | timestamp | 메시지 처리 시간         |
| failedAt    | timestamp | 마지막 실패 시간         |

## 4. 배치 전송

데이터를 비동기로 연동하는 가장 전통적인 방법, 일정 간격으로 데이터를 전송하는 방법
- DB에서 전송할 데이터를 조회
- 조회한 결과를 파일로 기록
- 파일을 연동 시스템에 전송

FTP나 SFTP 같은 파일 전송 프로토콜 혹은 SCP와 같은 명령어를 이용해 수행
- 값1(구분자)값2(구분자)값3
- 이름1=값1 이름2=값2 이름3=값3
- JSON 문자열

## 5. CDC(Change Data Capture)

변경된 데이터를 추적하고 판별해서 변경된 데이터로 작업을 수행할 수 있도록 하는 소프트웨어 설계 패턴으로, DB의 데이터가 변경되면, DB는 변경된 데이터를 CDC 처리기로 전송한다. 

- 변경 데이터를 그대로 대상 시스템에 전파
- 변경 데이터를 가공/변환해서 대상 시스템에 전파

CDC는 이벤트 메시지에 가깝지만, 이벤트처럼 정확하게 의미를 전달하지는 못한다.

변경 데이터를 어디까지 처리했는지 기록해야 하며, 그래야 CDC 처리기를 재시작할 때 마지막으로 조회한 로그부터 읽어올 수 있다.


---
## 심화학습

1. 왜 카프카는 Rabbit MQ와 달리 높은 처리량을 가질 수 있는걸까?

	설계 철학과 내부 구조가 완전히 다르기 때문.
	
	**디스크 기반 구조 + 순차 쓰기**
	Kafka는 로그 저장소 기반 스트리밍 플랫폼인 반면, RabbitMQ는 메시지 큐잉(브로커)이다. 카프카는 데이터를 메모리에 저장하지 않고 항상 디스크(파일)에 append-only 로그로 기록한다. (메모리에 쓰되 버퍼가 차면 디스크에 옮겨쓰긴 함.) 즉, 디스크에 데이터를 순차 쓰기로 처리하는 반면 Rabbit MQ는 큐에서 메시지를 꺼내고 삭제하는 랜덤 I/O 패턴이 발생해 디스크 접근 비용이 커진다. 

	**Zero-copy 기술**
	데이터를 네트워크로 보낼 때 유저공간(user space)을 거치지 않고 OS의 page cache > 소켓 버퍼로 직접 전송함. 데이터 복사가 일어나지 않기 때문에 CPU 부하와 컨텍스트 스위칭이 줄어듦. 반면 RabbitMQ는 메시지를 메모리 큐에서 읽어 소켓으로 복사하기 때문에 CPU 오버헤드가 큼

	**Pull 기반 소비**
	Consumer가 스스로 가져가는 Pull 모델을 사용함에 따라, consumer가 처리 가능한 만큼만 가져와 Backpressure가 자연스럽게 처리하는 반면, RabbitMQ는 Push 기반이라 Consumer가 느리면 Broker가 메시지를 밀어주며 큐에 쌓이고 Ack 처리 부담이 증가됨
		카프카에서 Backpressure는 consumer lag에 메시지가 쌓이고 이 크기만 늘어나지 시스템이 죽지는 않음

	**Offset기반 소비 구조**
	카프카는 메시지를 삭제하지 않고 Consumer가 어디까지 읽었는지(offset)를 기록. 여러 Consumer 그룹이 같은 데이터를 독립적으로 병렬 처리 가능한 반면, Rabbit MQ는 메시지를 전달 후 삭제하기 때문에 메시지 재전송, Ack/Nack 관리가 필수

	Batching & 압축
	카프카는 메시지를 배치(batch) 단위로 처리하고, 전송 시 압축(compression)을 적용
	RabbitMQ는 메시지 단위로 전송함에 따라 배치, 압축이 약함

	파티셔닝 + 병렬성
	카프카의 토픽은 여러 파티션으로 분할되어 각 파티션이 독립적으로 병렬 처리. 

2. Pull 방식일 때, 복수의 소비자(Consumer)가 어떻게 메시지를 읽어갈 수 있을까?
3. Push 방식은 브로커가 소비자에게 메시지를 전송하는데, 어떤 소비자가 있는지 어떻게 아는걸까?
	Queue에 컨슈머가 연결될 때 등록(subscribe) 하므로, 누가 컨슈머인지 이미 알고 있음

4. AMQP, STOMP 프토토콜이란?

	**AMQP(Advanced Message Queuing Protocol)**
	Producer > Exchange > Queue > Consumer
		Consumer가 Broker에게 "구독 요청"을 보냄
		Broker가 메시지를 Queue에 push
		Broker는 연결된 Consumer에 라운드 로빈 방식으로 메시지 분배

5. 요청/응답, 점대점 패턴이란?

	요청/응답(Request/Response)
		클라이언트가 요청을 보내고, 서버가 응답을 반환
		RPC, gRPC, HTTP, AMQP RPC
	점대점(Point-to-Point)
		메시지를 한 소비자만 처리
		Queue 모델
	발행/구독(Pub/Sub)
		여러 소비자가 같은 메시지를 각각 수신
		Topic 모델(Kafka, RabbitMQ Exchange/Topic)

6. 트랜잭션 아웃박스 패턴에서 메시지 중계 서비스가 2개 이상이라면, 어떻게 가져가게 처리해야할까?
	- DB row lock + skip locked 패턴(Postgres/MySQL 8+)
```SQL
WITH rows AS (
  SELECT id FROM outbox
  WHERE status = 'pending'
  ORDER BY created_at
  LIMIT 100
  FOR UPDATE SKIP LOCKED
)
UPDATE outbox
SET status = 'processing', locked_by = :worker_id, locked_at = now()
WHERE id IN (SELECT id FROM rows)
RETURNING *;
```

- 분산 락(Redis Redlock, Zookeeper, Consul)을 사용하여 워커가 메시지 획득 전에 분산 락을 획득해서 단일 워커만 수행하게 하기

7. MySQL을 통한 CDC 구현에서 위치 표기가 구체적으로 어떤 것을 말하는걸까?


8. CDC Connector가 이중화가 되어 있다면 어디까지 읽었는지 어떻게 알 수 있을까?
> 아키텍처 차원에서 정확히 한 번만 처리(Exactly-once semantics)를 보장할 수 있도록 구조를 설계해야 함
> DB -> CDC Connector (Debezium, Maxwell, etc.) -> 메시지 브로커(Kafka 등) -> CDC Processor

Debezium의 CDC Connector로서 아래와 같이 동작함
> MySQL (binlog)
> Debezium Connector (예: MySQL Connector)
> Kafka Topic (예: dbserver1.inventory.customers)


