> 기능을 개발할 때 기능의 실행 순서에 따라 프로그램을 작성하고 실행하면 동기(synchronous) 방식으로 동작한다. 즉, A가 B를 호출하는 로직이 있다고 가정했을 때, A는 B의 작업이 완료될 때까지 기다려야 한다. 하지만 B 서비스가 연동 서비스고 B 서비스에 이슈가 발생했다면?

다음 작업을 위해 반드시 호출한 작업의 결과가 필요한 것이 아니라면 비동기(asynchronous) 방식 채택을 고려해볼 수 있다.
- 연동에 약간의 시차가 발생해도 문제가 되지 않는 경우
- 일부 기능이 실패해도 재시도가 가능한 경우
- 연동에 실패했을 때 나중에 수동으로 처리할 수 있는 경우
- 연동에 실패했을 때 무시해도 되는 기능

## 1. 별도 스레드로 실행하기

스레드를 생성하거나, 스레드 풀을 이용하거나 혹은 프레임워크에서 제공하는 비동기 기능(e.g., @Async)을 사용해서 처리한다.

단, 별도 스레드로 연동할 경우 오류 처리에 대해 더 신경을 써줘야 한다. 

Exception 전파가 소용없기 때문!

## 2. 메시징

서로 다른 시스템 간 비동기 연동을 위해 주로 메시징 시스템을 사용한다.
- 두 시스템이 서로 영향을 주지 않는다.
	- A 시스템 트래픽 급증 시, B 시스템 성능 저하로 인한 장애 전파가 일어나지 않음
- 확장이 용이하다.
	- A 시스템이 C 에도 데이터를 전송해야 한다면, C를 메시지 시스템에 연결만 하면 됨

카프카(Kafka)
- 높은 처리량, 초당 백 만 개 이상의 메시지를 처리할 수 있음
- 수평 확장이 용이. 서버(브로커), 파티션, 소비자를 늘리면 됨
- 카프카는 메시지를 파일에 보관해서 유실되지 않음
- 1개의 토픽이 여러 파티션을 가질 수 있는데, 파티션 단위로 순서를 보장. (토픽 수준에서는 순서 보장 X)
- 소비자는 메시지를 언제든지 재처리 가능
- **풀(pull) 모델** 사용, 소비자가 카프카 브로커에서 메시지를 읽어 가는 방식

Rabbit MQ
- 클러스터를 통해 처리량을 높일 수 있다. 단, 카프카보다 더 많은 자원을 피룡로 함
- 메모리에만 메시지를 보관하는 큐 설정을 사용하면 장애 상황 시 메시지가 유실될 수 있음
- 메시지는 큐에 등록된 순서대로 소비자에 전송
- 메시지가 소비자에 전달됐는지 확인하는 기능 제공
- **푸시(push) 모델** 사용, Rabbit MQ 브로커가 소비자에게 메시지를 전송함. 소비자의 성능이 느려지면 큐에 과부하가 걸려 전반적으로 성능 저하가 발생할 수 있음.
- 다재 다능. AMQP, STOMP 등 여러 프로토콜을 지원하고, pub/sub 패턴 뿐만 아니라 요청/응답, 점대점패턴을 지원함. 우선순위를 지정해서 처리 순서를 변경할 수 있음

레디스 pub/sub
- 메모리를 사용하므로 지연 시간이 짧고, Rabbit MQ 대비 처리량이 높다.
- 구독자가 없으면 메시지가 유실된다.
- 기본적으로 영구 메시지를 지원하지 않는다.
- 모델이 단순해서 사용하기 쉽다.

> 기술을 선택할 때는 개인의 호기심이나 취향보다는 조직의 역량과 지속 가능성을 고려해야 함

### 2.1 메시지 생산자 측 유의할 점

**메시지 유실**
- 무시하기
	- 단순 로그 메시지인 경우 유실되어도 됨
- 재시도하기
	- 일시적 오류는 재시도를 통해 해결될 수 있음
- 실패 로그 남기기
	- 실패 로그를 남겨 후처리 진행


**DB 트랜잭션**
메시지 전송 후 DB 트랜잭션이 롤백되면 잘못된 메시지가 전송될 수 있음. 트랜잭션이 끝난 뒤에 메시지 전송하는 것이 좋음

### 2.2 메시지 소비자 측 유의할 점

- 메시지 생산자의 중복 메시지 발행
	- 메시지에 고유 ID를 부여하여 처리 여부를 추적
- 소비자가 메시지를 처리하는 과정에서 오류가 발생하여 재수신
	- API의 멱등성 보장, 동일 요청에 대한 중복 처리를 해도 결과는 일치

### 2.3 이벤트와 커맨드

**이벤트(Event)**
- 어떤 일이 발생했음을 알려주는 메시지(e.g., "주문함", "로그인에 실패함")
- 상태 변경과 관련있거나, 어떤 활동이 일어났다는 사실을 나타냄
- 정해진 수신자가 없음
- thqlwk ghkrwkddp wjrgkq

**커맨드(Command)**
- 무언가를 요청하는 메시지(e.g, "포인트 지급하기", "로그인 차단하기")
- 메시지를 수신할 측의 기능 실행에 초점이 맞춰져 있음

## 3. 트랜잭션 아웃박스 패턴

잘못된 메시지 발송을 방지하기 위해 DB 트랜잭션 완료 후에 메시지를 전송한다고 하더라도, 시스템 연동에 실패하는 등 완벽하지 않을 수 있다. 메시지 데이터 자체가 유실되지 않도록 보장하기 위해서는 해당 메시지를 DB에 저장하면 되는데, 이를 **트랜잭션 아웃박스 패턴**이라고 한다.

- 실제 업무 로직에 필요한 DB 작업 수행
- 메시지 데이터 아웃박스 테이블에 추가

한 DB 트랜잭션 범위 내에서 추가하므로, 실패할 경우 같이 롤백이 됨

발송 완료 표기를 위해서는 아래 두 가지 방법 채택 가능
- 아웃박스 테이블에 발송 상태 컬럼을 두는 것
- 메시지 중계 서비스가 성공적으로 전송한 마지막 메시지 ID 기록

아웃박스 테이블 구조

| 컬럼          | 타입        | 설명                |
| ----------- | --------- | ----------------- |
| id          | big int   | 단순 증가 값(PK)       |
| messageId   | varchar   | 메시지 고유 ID(UNIQUE) |
| messageType | varchar   | 메시지 타입            |
| payload     | clob      | 메시지 데이터           |
| status      | varchar   | 이벤트 처리 상태         |
| failCount   | int       | 실패 횟수             |
| occuredAt   | timestamp | 메시지 발생 시간         |
| processedAt | timestamp | 메시지 처리 시간         |
| failedAt    | timestamp | 마지막 실패 시간         |

## 4. 배치 전송

데이터를 비동기로 연동하는 가장 전통적인 방법, 일정 간격으로 데이터를 전송하는 방법
- DB에서 전송할 데이터를 조회
- 조회한 결과를 파일로 기록
- 파일을 연동 시스템에 전송

FTP나 SFTP 같은 파일 전송 프로토콜 혹은 SCP와 같은 명령어를 이용해 수행
- 값1(구분자)값2(구분자)값3
- 이름1=값1 이름2=값2 이름3=값3
- JSON 문자열

## 5. CDC(Change Data Capture)

변경된 데이터를 추적하고 판별해서 변경된 데이터로 작업을 수행할 수 있도록 하는 소프트웨어 설계 패턴으로, DB의 데이터가 변경되면, DB는 변경된 데이터를 CDC 처리기로 전송한다. 

- 변경 데이터를 그대로 대상 시스템에 전파
- 변경 데이터를 가공/변환해서 대상 시스템에 전파

CDC는 이벤트 메시지에 가깝지만, 이벤트처럼 정확하게 의미를 전달하지는 못한다.

변경 데이터를 어디까지 처리했는지 기록해야 하며, 그래야 CDC 처리기를 재시작할 때 마지막으로 조회한 로그부터 읽어올 수 있다.


---
## 심화학습

1. 왜 카프카는 Rabbit MQ와 달리 높은 처리량을 가질 수 있는걸까?
2. Pull 방식일 때, 복수의 소비자(Consumer)가 어떻게 메시지를 읽어갈 수 있을까?
3. Push 방식은 브로커가 소비자에게 메시지를 전송하는데, 어떤 소비자가 있는지 어떻게 아는걸까?
4. AMQP, STOMP 프토토콜이란?
5. 요청/응답, 점대점 패턴이란?
6. 트랜잭션 아웃박스 패턴에서 메시지 중계 서비스가 2개 이상이라면, 어떻게 가져가게 처리해야할까?
7. MySQL을 통한 CDC 구현에서 위치 표기가 구체적으로 어떤 것을 말하는걸까?
8. CDC 처리기도 이중화가 되어 있다면 어디까지 읽었는지 어떻게 알 수 있을까?